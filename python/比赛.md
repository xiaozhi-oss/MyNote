# 一、jieba库-分词

## 1	模式

1.  精确模式，试图将句子最精确地切开，适合文本分析；
2.  全模式，把句子中所有的可以成词的词语都扫描出来, 速度非常快，但是不能解决歧义；
3.  搜索引擎模式，在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。
4.  paddle模式，利用PaddlePaddle深度学习框架，训练序列标注（双向GRU）网络模型实现分词。同时支持词性标注。



## 2	用法

```python
# encoding=utf-8
import jieba

#jieba.enable_paddle()
# 启动paddle模式。 0.40版之后开始支持，早期版本不支持
strs=["我来到北京清华大学","乒乓球拍卖完了","中国科学技术大学"]
for str in strs:
    seg_list = jieba.cut(str,use_paddle=True) # 使用paddle模式
    print("Paddle Mode: " + '/'.join(list(seg_list)))

seg_list = jieba.cut("我来到北京清华大学", cut_all=True)
print("Full Mode: " + "/ ".join(seg_list))  # 全模式

seg_list = jieba.cut("我来到北京清华大学", cut_all=False)
print("Default Mode: " + "/ ".join(seg_list))  # 精确模式

seg_list = jieba.cut("他来到了网易杭研大厦")  # 默认是精确模式
print(", ".join(seg_list))

seg_list = jieba.cut_for_search("小明硕士毕业于中国科学院计算所，后在日本京都大学深造")  # 搜索引擎模式
print(", ".join(seg_list))
```



## 3	添加自定义字典

```python
 jieba.load_userdict(file_name)
```



## 4	关键词提取

### ①基于 TF-IDF 算法的关键词抽取

-   **jieba.analyse.extract_tags(sentence, topK=20, withWeight=False, allowPOS=())**
    -   sentence 为待提取的文本
    -   topK 为返回几个 TF/IDF 权重最大的关键词，默认值为 20
    -   withWeight 为是否一并返回关键词权重值，默认值为 False
    -   allowPOS 仅包括指定词性的词，默认值为空，即不筛选
-   jieba.analyse.TFIDF(idf_path=None) 新建 TFIDF 实例，idf_path 为 IDF 频率文件

**代码演示**

```python
import requests
import jieba
from jieba import analyse

url = "http://72.itmc.org.cn/JS001/data/user/13436/61/fj_chiffon_lady_dress.txt"
rep = requests.get(url)
rep.encoding = 'utf-8'
ready_text = rep.text.splitlines()

# 处理文本
ana_text = ''

# 添加文本
ana_text += ready_text[1] + '。'
for line in ready_text[4:25]:
 if ':' in line:
  ana_text += line.split(':')[1]
 else:
  ana_text += line.split('：')[1]

# print(ready_text)
ana_text += ready_text[27]
print(ana_text)

print(analyse.tfidf(sentence=ana_text, topK=5, allowPOS=('nr', 'ns', 'n')))
```





# 二、BS4-解析HTML

## 1	简介

[Beautiful Soup ](https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/)是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式。

**文档**

https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id14



## 2	常用方法

### 解析器

![image-20211030193506518](E:\学习笔记\img\20211030193508.png)

**说明**：通过pip install来安装对应的解析器



### ①解析HTML内容





### ②获取信息



### ③遍历文档树





### ③搜索文档树





## 3	总结

**①select函数**

-   的用法跟css选择器一样，把它当做选择器就好了

-   返回的是**ResultSet(结果集)类型**，取值的时候可以使用下角标去取值，取出来的是**Tag类型**

-   Tag类型可以使用**text函数**，ResultSet类型是不能使用text函数的，会报错

    



### ②find和findAll函数

-   find函数返回的是Tag类型，所以是可以使用text函数的
-   findAll函数返回的是ResultSet类型，可以遍历它
-   findAll函数不能像select函数一样使用，要注意两者的用法

**注意点**：

-   find函数如果没有查到会返回**NoneType类型**，findAll函数如果没有查到就会返回空的这个时候如果调用函数的话就会报错
-   findAll函数如果没有查到就会**返回空的列表**，这个时候使用下角标取值就会报下角标的错误





### ③Tag类

tag的可以通过`.`来调用它的子节点，

**例**：div.span.a就是div下的span下的a标签

==**注意**：Tag类是可以调用select函数和find函数、findAll函数的==



### ④ResultSet类

它是一个结果集，就是有很多的结果

通过遍历它可以得到多个Tag对象



### ⑤使用的场合

-   find和findAll方法适用于标签有对应的id或者class的时候
-   select函数使用于每个标签都是没有特别的标识的，比如表格中的tr，td
-   查找的时候要具体，**最好是通过标签名和类名一起查找**





# 三、Pandas-数据分析

## 1	概述

### ①pandas的用途

Pandas 是 [Python](https://www.python.org/) 的核心数据分析支持库，提供了快速、灵活、明确的数据结构，旨在简单、直观地处理关系型、标记型数据。

1.  一个快速、高效的DataFrame对象，用于数据操作和综合索引；
2.  用于在内存数据结构和不同格式之间读写数据的工具：CSV和文本文件、Microsoft Excel、SQL数据库和快速HDF 5格式；
3.  智能数据对齐和丢失数据的综合处理：在计算中获得基于标签的自动对齐，并轻松地将凌乱的数据操作为有序的形式；
4.  数据集的灵活调整和旋转；
5.  基于智能标签的切片、花式索引和大型数据集的子集；
6.  可以从数据结构中插入和删除列，以实现大小可变；
7.  通过在强大的引擎中聚合或转换数据，允许对数据集进行拆分应用组合操作;
8.  数据集的高性能合并和连接；
9.  层次轴索引提供了在低维数据结构中处理高维数据的直观方法；
10.  时间序列-功能：日期范围生成和频率转换、移动窗口统计、移动窗口线性回归、日期转换和滞后。甚至在不丢失数据的情况下创建特定领域的时间偏移和加入时间序列；



### ②安装

```shell
pip install pandas
```



### ③数据结构

![img](https://note.youdao.com/yws/public/resource/592a20cd8dd37887533b3d68b0fbc736/xmlnote/296FFCF1A94B4BD0AB8D4BD1079817F6/4393)

Pandas 数据结构就像是低维数据的容器。比如，DataFrame 是 Series 的容器，Series 则是数据等标量的容器。使用这种方式，可以在容器中以字典的形式插入或删除对象。





## 2	Series

### ①生成Series对象

首先导入需要的类库

```python
import numpy as np
import pandas as pd
```



#### 1.从标量值创建

```python
s = pd.Series(25, index=['a', 'b', 'c'])
print(s)
# 遍历得到每一个value值
for i in s:
    print(i)
```

![image-20211102190706141](E:\学习笔记\img\20211102190708.png)



#### 2.从字典类型创建

```python
s = pd.Series({"a":9, "b":9, "c":7}, index=['c', 'a', 'b', 'd'])
print(s)
```

![image-20211102190756812](E:\学习笔记\img\20211102190758.png)

#### 3.从Numpy中的ndarray类型创建

```python
m = pd.Series(np.arange(5), index=np.arange(9, 4, -1))
print(m)
```

**说明**：numpy的arange函数和python中的range函数是一样的用法



### ②基础操作

#### 1.获取

-   index：获取索引
-   values：获取值

```python
import pandas as pd

s = pd.Series({'a':9,'b':9,'c':7},index=['c','a','b','d'])
# 获取索引
print(s.index)  # Index(['c', 'a', 'b', 'd'], dtype='object')
# 获取值
print(s.values) # [ 7.  9.  9. nan] 注：nan为Nan，就是为空
# 切片操作
print(s['a'])   # 9.0
print(s[:2])  
```



### 2.对齐





## 3	DataFrame

DataFrame是一个表格型的数据类型，每列值类型可以不一样（和myslq类似）。



### ①生成

#### 1.从二维ndarray对象创建

```python
# 从二维ndarray对象创建
d = pd.DataFrame(np.arange(10).reshape(2, 5))
'''
	说明：
		np.arange(10)：和range的用法一样，生成0-9
		reshape(2,5)：两行五列排版
'''
print(d)
```

![image-20211102212744035](E:\学习笔记\img\20211102212745.png)



#### 2.从一维ndarray对象字典创建

```python
#从一维ndarray对象字典创建
dt = {
    'one':pd.Series([1, 2, 3], index=['a', 'b', 'c']),
    'two':pd.Series([5, 6, 7, 8], index=['a', 'b', 'c', 'd'])
}
d = pd.DataFrame(dt)
print(d)
```

![image-20211102212750549](E:\学习笔记\img\20211102212751.png)

**疑惑**：如果index索引都不一样会怎样

```python
d = pd.DataFrame(dt)
print(d)
dt = {
    'one':pd.Series([1, 2, 3], index=['e', 'f', 'g']),
    'two':pd.Series([5, 6, 7, 8], index=['a', 'b', 'c', 'd'])
}
d = pd.DataFrame(dt)
print(d)
```

![image-20211104171047311](E:\学习笔记\img\20211104171049.png)



#### 3.从列表类型的字典创建

```python
d1 = {
    'one':[1, 2, 3, 4],
    'two':[9, 8, 7, 6]
}
d = pd.DataFrame(d1, index=['a', 'b', 'c', 'd'])
print(d)
```

![image-20211102213010619](E:\学习笔记\img\20211102213011.png)



#### 4.多重索引

```python
import numpy as np
import pandas as pd

d = [
    [95, 99, 89, 60],
    [77, 56, 68, 58],
    [92, 88, 29, 98],
    [22, 54, 73, 62]
]

data = pd.DataFrame(d, columns=['shuxue', 'yuwen', 'yingyu', 'shengwu'],
                    index=[['banji1', 'banji1', 'banji2', 'banji2'],
                           ['xiaoMing', 'HanHan', 'Geyou', 'FengGong']])
print(data)
```

![image-20211102213446191](E:\学习笔记\img\20211102213447.png)

**说明**：

-   colums参数表示的就是列名，有多少列是由它决定的
-   index就是索引，类似mysql中的主键
-   多重索引就是有多个索引



### ②基础操作

DataFrame是二维带“标签”数组

#### 1.获取

```python
import pandas as pd

# 生成DataFrame
dt = {
    "one": pd.Series([3, 1, 4], index=['b', 'a', 'c']),
    "two": pd.Series([6, 5, 9], index=['a', 'c', 'b'])
}
print('========显示头部和尾部数据========')
d = pd.DataFrame(dt)
# 获取头部数据 --> 只显示头部1行数据
print(d.head(1))
# 查看尾部数据 --> 只显示尾部2行数据
print(d.tail(2))

print('========查看统计数据========')
# 查看统计数据 --> 数学上的统计，比如count是个数，mean是平均值，std是标准差...
print(d.describe())

print('========按轴排序========')
# 按轴排序，列索引排序，降序 --> axis=1是行索引排序，ascending=True表示开启升序
#                       --> axis=0是列索引排序，ascending=False表示开启降序
print(d.sort_index(axis=1, ascending=False))
print(d.sort_index(axis=1, ascending=True))
print(d.sort_index(axis=0, ascending=False))
print(d.sort_index(axis=0, ascending=True))

print('========按值排列========')
# 按值排序 --> 按索引two的比较来进行排序
print(d.sort_values(by="two"))

print('========选择单列========')
# 选择单列 --> 输出一个Series
print(d['one'])

print('========用[]切片行========')
# 用[]切片行 --> 和列表的用法一样
print(d[1:3])

print('========用标签提取一行数据========')
# 用标签提取一行数据 --> 得到一个纵向的Series
print(d.loc['a'])

print('========选择多行多列========')
print(d.loc['a': 'b':])
print(d.loc[('a', 'b'),])       # 逗号不能少，少了就会报错
print(d.loc[:,'one': 'two'])    # 冒号和逗号都不能少，少了会报错
# 注意：loc是索引或者key来取值的，位置很重要，第一行的才是索引，所以它是会根据第一行的去取值

print('========按照位置选择========')
# 按照位置选择
print(d.iloc[2])
print(d.iloc[:,1:2])    # 输出
print(d[d.one > 2])     # 输出one这列中大于2的一行

print('========items函数返回一个zip类型========')
# zip类型是有name和value两个值的
for key, value in p.items():
	print(key, value)
```

![image-20211104175353438](E:\学习笔记\img\20211104175354.png)

#### 2.算数运算

##### **①缺失值**

在dataframe中为nan或者naT（缺失时间），在series中为none或者nan即可

```python
import pandas as pd
import numpy as np

df = pd.DataFrame(
    {"name": ['Alfred', 'Batman', 'CatWoman'],
     "toy": [np.nan, "Batmobie", "Bullwhip"],
     "born": [pd.NaT, pd.Timestamp("1940-04-25"), pd.NaT]}
)
print("=========初始========")
print(df)

# 删除行，只要有空值就会删除，不替换
print("=======删除空值后=======")
print(df.dropna())

print("=========删除列有空值的列========")
print(df.dropna(axis=1))    # axis=1表示是列，axis=0表示的是行

print("=========所有值是缺失值才删除========")
print(df.dropna(how='all'))

print("=========至少出现两个空缺值才删除========")
print(df.dropna(thresh=2))

print("=========判断是否是空缺值========")
print(df.isna())

print("=========空缺值替换========")
print(df.fillna(0)) # 将所有空值替换成0
# df.fillna(values=values)
```

![image-20211104215104640](E:\学习笔记\img\20211104215106.png)



##### **②分组**

```python
import pandas as pd
import numpy as np

print("==========初始化==========")
df = pd.DataFrame(
    {'A': ['foo', 'bar', 'foo', 'bar'
        , 'foo', 'bar', 'foo', 'foo'],
     'B': ['one', 'one', 'two', 'three'
         , 'two', 'two', 'one', 'three'],
     'C': np.random.randn(8),
     'D': np.random.randn(8)}
)
print(df)

print("==========索引分组==========")
'''
    说明：①分组就是在数据中有多个张三，他们其实是一个，所以将他们合并
         ②这个分组类似于MySQL中的分组，sum函数和MySQL中的函数类似
         ③分组中字母相同就合并成一个，数字相同就相加，其他不相同的就不合并
'''
# 相加
print(df.groupby('A').sum())
print(df.groupby(['A', 'B']).sum())
'''
	注意：
		①分组之后的索引就是以它分分组的那个索引，比如我以name分组，那么索引就是name那一列了
		②分组之后[]，这个括号里面是分组之后需要的列，不需要的它不会在里面
			eg：pd.groupby("name")['age']，数据就是索引为那么，value为age那一列
			eg: pd.groupby("name","sex")['age'],数据就是两个索引，一列数据
		③多重索引它的前后顺序也是有差别的
			eg: pd.groupby('name', 'sex'),它会先分名字，后分性别
			eg：pd.groupby('sex', 'name'),它会先分性别，在分名字，也就是说第一层索引只有男女
'''
```

![image-20211104215207953](E:\学习笔记\img\20211104215209.png)

##### **③加减乘除**

里面的数据都执行一个操作

```python
df = pd.DataFrame({'angles': [0, 6, 4],
                   'degrees': [360, 180, 360]},
                  index=['circle', 'triangle', 'rectangle'])
print("=========初始化==========")
print(df)

print("==========加减乘除==========")
# 就是里面的值都加1
print(df.add(1))    # 等价于 --> df + 1
print(df.sub(1))    # 等价于 --> df - 1
print(df.div(2))    # 等价于 --> df / 2
print(df.mul(3))    # 等价于 --> df * 3

# 两个列相加减也是可以的	-->		前提必须是两个都是数字类型的，如果不是就会报错！！！
df['test'] = df['angles'] * df['degrees']	# 新生成的那一列就是两列相乘的结果，一行乘一行
```

![image-20211104215334831](E:\学习笔记\img\20211104215336.png)



#### 3.技巧

不用方法也可以实现分析，不过是有点麻烦~~~

-   **values属性**

    ![image-20211105143121338](E:\学习笔记\img\20211105143122.png)

-   **len(df.count())**     key的个数

-   **len(df)**                   索引的个数

-   **df[0]**                       得到为0的这一列数据

    ![image-20211105143543238](E:\学习笔记\img\20211105143544.png)

**说明**：df是DataFrame对象

**代码实现**

```python
# 遍历所有值，有多少个索引就有多少行数据，每一行数据都是一个数组
for i in df.values:
    print(i)
    
# i是一列数据的每一个数据
for i in df[0]:
    print(i)
```

![image-20211105144653773](E:\学习笔记\img\20211105144654.png)
