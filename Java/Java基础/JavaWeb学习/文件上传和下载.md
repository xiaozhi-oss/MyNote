# 文件上传

文件的上传和下载，是非常常见的功能。很多的系统中，或者软件中都经常使用文件的上传和下载。 

比如：QQ 头像，就使用了上传。 

邮箱中也有附件的上传和下载功能。 OA 系统中审批有附件材料的上传。



## 文件上传介绍

1. 要有一个 form 标签，method=post 请求 

2. form 标签的 encType 属性值必须为 multipart/form-data 值 

3. 在 form 标签中使用 input type=file 添加上传的文件

4. 编写服务器代码（Servlet 程序）接收，处理上传的数据。

   req.getInputStream()方法获取到请求体的信息

**encType=multipart/form-data** 表示提交的数据，以多段（每一个表单项一个数据段）的形式进行拼 接，然后以二进制流的形式发送给服务器

**注意**：form标签上一定要加	enctype="multipart/form-data"属性，如果没有设置是不会以多段的形式返回的



**jsp页面**

```jsp
<body>
<form action="http://localhost:8080/EL/uploadServlet" method="post" enctype="multipart/form-data">
    用户名<input type="text" name="username"><br>
    头像<input type="file" name="photo"><br>
    <input type="submit" value="上传">
</form>
</body>
```

**java代码**

```java
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletInputStream inputStream = req.getInputStream();
        byte[] buffer = new byte[102400];
        int read = inputStream.read(buffer);
        System.out.println(new String(buffer,0,read));
    }
```

**结果显示**

![image-20201211213950254](C:\Users\猛男\AppData\Roaming\Typora\typora-user-images\image-20201211213950254.png)

**补充**：这就是html协议中的响应体了





## 第三方解析

### commons-fileupload.jar 常用 API 介绍说明

​	commons-fileupload.jar 需要依赖 commons-io.jar 这个包，所以两个包我们都要引入。 

​	第一步，就是需要导入两个 jar 包： 

​		commons-fileupload-1.2.1.jar 

​		commons-io-1.4.jar commons-fileupload.jar 和 commons-io.jar 包中，

**我们常用的类有哪些？** 

- ServletFileUpload 类，用于解析上传的数据。

- FileItem 类，表示每一个表单项。 

- boolean ServletFileUpload.isMultipartContent(HttpServletRequest request); 判断当前上传的数据格式是否是多段的格式。 

- public List parseRequest(HttpServletRequest request) 解析上传的数据 

- boolean FileItem.isFormField() 判断当前这个表单项，是否是普通的表单项。还是上传的文件类型。 

  ​		true 表示普通类型的表单项 

  ​		false 表示上传的文件类型 

- String FileItem.getFieldName() 获取表单项的 name 属性值

- String FileItem.getString() 获取当前表单项的value值。

- String FileItem.getName(); 获取上传的文件名 

- void FileItem.write( file ); 将上传的文件写到 参数 file 所指向抽硬盘位置 。



**代码实现**

```java
	@Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 1.判断是否是已多段的形式上传的
        if (ServletFileUpload.isMultipartContent(req)){
            // 获取fileItemFactory工厂类的实现类
            FileItemFactory fileItemFactory = new DiskFileItemFactory();
            // 获取解析上传数据的工具类servletFileUpload
            ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory);
            try {
                // 解析上传的数据，获取每一个表单项
                List<FileItem> list = servletFileUpload.parseRequest(req);
                // 遍历得到每个表单项
                for (FileItem fileItem : list){
                    // 普通的表单项
                    if (fileItem.isFormField()){
                        System.out.println(fileItem.getFieldName());    // 获取表单项的name属性值
                        // 参数 UTF-8.解决乱码问题
                        System.out.println(fileItem.getString("UTF-8"));  // 获取当前表单项value的值
                    }else {
                        // 上传的文件类型的表单项
                        System.out.println(fileItem.getName());    //  获取上传文件的文件名
                        // 将文件写到file指定的硬盘上
                        fileItem.write(new File("e://" + fileItem.getName()));
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
```







## 文件上传，HTTP 协议的说明

![image-20201211222350960](C:\Users\猛男\AppData\Roaming\Typora\typora-user-images\image-20201211222350960.png)









# 文件下载

- getServletContext();		获取servletContext对象

- servletContext.getMimeType("文件的位置")				获取下载文件的类型

  ​	以“/”打头，映射到当前工程目录下

- servletContext.getResourceAsStream("文件名")         获取一个放着文件内容的流

- resp.getOutputStream();             获取一个输出流

- resp.setHeader("Content-Disposition", "attachment; fileName=1.jpg");        告诉客户端收到的数据是用于下载使用的

  ​	attachment 表示附件，也就是下载的一个文件

  ​	fileName="文件名"， 表示下载的文件名

- IOUtils.copy(inputStream,outputStream);           把下载的文件回传给给客户端

**注意**：设置响应头要在传输之前设置，不然会没有效果的



**代码实现**

```java
@Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 1.获取要下载的文件名
        String downloadName = "2.jpg";
        // 2.读取下载的文件内容，通过ServletConetext对象读取
        ServletContext servletContext = getServletContext();
        String mimeType = servletContext.getMimeType("/file/" + downloadName);
        System.out.println("下载的文件类型为：" + mimeType);
        // 4.在回传前，通过响应头告诉客户端返回的数据类型
        resp.setContentType(mimeType);
        InputStream inputStream = servletContext.getResourceAsStream("/file/" + downloadName);
        OutputStream outputStream = resp.getOutputStream();
        // 5.还要告诉客户端收到的数据是用于下载使用的（还是使用响应头）
        resp.setHeader("Content-Disposition", "attachment; fileName=1.jpg");
        // 3.把下载的文件回传给客户端
        IOUtils.copy(inputStream,outputStream);
    }
```





## 解决下载文件中文乱码



### 方案一（URLEncoder）

URLEncoder.encode("文件名", "编码集");		对文件名进行编码

"attachment"表示是附件，fileName表示文件名

setHeader("Content-Disposition", str)方法中的"Content-Disposition"是告诉浏览器有文件下载

```java
		// 把中文名进行 UTF-8 编码操作。
        String str = "attachment; fileName=" + URLEncoder.encode("中国.jpg", "UTF-8");
        // 然后把编码后的字符串设置到响应头中
        resp.setHeader("Content-Disposition", str);
```





### 方案二（BASE64 编解码）

```java
// 使用下面的格式进行 BASE64 编码后
        String str = "attachment; fileName=" + "=?utf-8?B?"
                + new BASE64Encoder().encode("中文.jpg".getBytes("utf-8")) + "?=";
        // 设置到响应头中
        resp.setHeader("Content-Disposition", str);
```





### 方案三

**思想**：进行响应头判断，是那个浏览器就用那个编码

由于URLEncoder三者（谷歌、火狐、IE）都可以使用，在这里就不多演示















