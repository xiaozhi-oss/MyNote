# 自定义封装类

## MD5Utils密码加密

### 1、自定义

#### 第一种方式

```java
/**
 * MD5加密工具类
 */
public class MD5Util {

    private static String byteArrayToHexString(byte b[]) {
        StringBuffer resultSb = new StringBuffer();
        for (int i = 0; i < b.length; i++)
            resultSb.append(byteToHexString(b[i]));

        return resultSb.toString();
    }

    private static String byteToHexString(byte b) {
        int n = b;
        if (n < 0)
            n += 256;
        int d1 = n / 16;
        int d2 = n % 16;
        return hexDigits[d1] + hexDigits[d2];
    }

    public static String MD5Encode(String origin, String charsetname) {
        String resultString = null;
        try {
            resultString = new String(origin);
            MessageDigest md = MessageDigest.getInstance("MD5");
            if (charsetname == null || "".equals(charsetname))
                resultString = byteArrayToHexString(md.digest(resultString
                        .getBytes()));
            else
                resultString = byteArrayToHexString(md.digest(resultString
                        .getBytes(charsetname)));
        } catch (Exception exception) {
        }
        return resultString;
    }
	
    // 也可以是你自己设定的十六进制的数
    private static final String hexDigits[] = {"0", "1", "2", "3", "4", "5",
            "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"};
}
```



#### 第二种方式

```java
public final class MD5 {

    public static String encrypt(String strSrc) {
        try {
            char hexChars[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8',
                    '9', 'a', 'b', 'c', 'd', 'e', 'f' };
            byte[] bytes = strSrc.getBytes();
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(bytes);
            bytes = md.digest();
            int j = bytes.length;
            char[] chars = new char[j * 2];
            int k = 0;
            for (int i = 0; i < bytes.length; i++) {
                byte b = bytes[i];
                chars[k++] = hexChars[b >>> 4 & 0xf];
                chars[k++] = hexChars[b & 0xf];
            }
            return new String(chars);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            throw new RuntimeException("MD5加密出错！！+" + e);
        }
    }
}
```



### 2、spring内置的md5

```java
// MD5加密
public static String md5(String key) {
    if (StringUtils.isBlank(key)) {
        return null;
    }
    return DigestUtils.md5DigestAsHex(key.getBytes());
}
```





## 实体类公共类

```java
@Data
public class BaseEntity implements Serializable {

    @ApiModelProperty(value = "id")
    @TableId(type = IdType.AUTO)
    private Long id;

    @ApiModelProperty(value = "创建时间")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @TableField("create_time")
    private Date createTime;

    @ApiModelProperty(value = "更新时间")
    @TableField("update_time")
    private Date updateTime;

    @ApiModelProperty(value = "逻辑删除(1:已删除，0:未删除)")
    @TableLogic
    @TableField("is_deleted")
    private Integer isDeleted;

    @ApiModelProperty(value = "其他参数")
    // 不会在数据库中存在的字段
    @TableField(exist = false)
    private Map<String,Object> param = new HashMap<String,Object>();
}
```

**说明**：特定的情况特定处理



## 全局统一返回结果类

```java
/**
 * 全局统一返回结果类
 */
@Data
@ApiModel(value = "全局统一返回结果")
public class Result<T> {

    @ApiModelProperty(value = "返回码")
    private Integer code;

    @ApiModelProperty(value = "返回消息")
    private String message;

    @ApiModelProperty(value = "返回数据")
    private T data;

    public Result(){}

    protected static <T> Result<T> build(T data) {
        Result<T> result = new Result<T>();
        if (data != null)
            result.setData(data);
        return result;
    }

    public static <T> Result<T> build(T body, ResultCodeEnum resultCodeEnum) {
        Result<T> result = build(body);
        result.setCode(resultCodeEnum.getCode());
        result.setMessage(resultCodeEnum.getMessage());
        return result;
    }

    public static <T> Result<T> build(Integer code, String message) {
        Result<T> result = build(null);
        result.setCode(code);
        result.setMessage(message);
        return result;
    }

    public static<T> Result<T> ok(){
        return Result.ok(null);
    }

    /**
     * 操作成功
     * @param data
     * @param <T>
     * @return
     */
    public static<T> Result<T> ok(T data){
        Result<T> result = build(data);
        return build(data, ResultCodeEnum.SUCCESS);
    }

    public static<T> Result<T> fail(){
        return Result.fail(null);
    }

    /**
     * 操作失败
     * @param data
     * @param <T>
     * @return
     */
    public static<T> Result<T> fail(T data){
        Result<T> result = build(data);
        return build(data, ResultCodeEnum.FAIL);
    }

    public Result<T> message(String msg){
        this.setMessage(msg);
        return this;
    }

    public Result<T> code(Integer code){
        this.setCode(code);
        return this;
    }

    public boolean isOk() {
        if(this.getCode().intValue() == ResultCodeEnum.SUCCESS.getCode().intValue()) {
            return true;
        }
        return false;
    }
}
```



**统一返回结果状态信息类**

```java
/**
 * 统一返回结果状态信息类
 */
@Getter
public enum ResultCodeEnum {

    SUCCESS(200,"成功"),
    FAIL(201, "失败"),
    PARAM_ERROR( 202, "参数不正确"),
    SERVICE_ERROR(203, "服务异常"),
    DATA_ERROR(204, "数据异常"),
    DATA_UPDATE_ERROR(205, "数据版本异常"),

    LOGIN_AUTH(208, "未登陆"),
    PERMISSION(209, "没有权限"),

    CODE_ERROR(210, "验证码错误"),
//    LOGIN_MOBLE_ERROR(211, "账号不正确"),
    LOGIN_DISABLED_ERROR(212, "改用户已被禁用"),
    REGISTER_MOBLE_ERROR(213, "手机号已被使用"),
    LOGIN_AURH(214, "需要登录"),
    LOGIN_ACL(215, "没有权限"),

    URL_ENCODE_ERROR( 216, "URL编码失败"),
    ILLEGAL_CALLBACK_REQUEST_ERROR( 217, "非法回调请求"),
    FETCH_ACCESSTOKEN_FAILD( 218, "获取accessToken失败"),
    FETCH_USERINFO_ERROR( 219, "获取用户信息失败"),
    //LOGIN_ERROR( 23005, "登录失败"),

    PAY_RUN(220, "支付中"),
    CANCEL_ORDER_FAIL(225, "取消订单失败"),
    CANCEL_ORDER_NO(225, "不能取消预约"),

    HOSCODE_EXIST(230, "医院编号已经存在"),
    NUMBER_NO(240, "可预约号不足"),
    TIME_NO(250, "当前时间不可以预约"),

    SIGN_ERROR(300, "签名错误"),
    HOSPITAL_OPEN(310, "医院未开通，暂时不能访问"),
    HOSPITAL_LOCK(320, "医院被锁定，暂时不能访问"),
    ;

    private Integer code;
    private String message;

    private ResultCodeEnum(Integer code, String message) {
        this.code = code;
        this.message = message;
    }
}
```





## 分页类封装

```java
package com.newkewang.utils;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @author xiaozhi
 * @description 封装分页相关信息
 * @create 2022-03-2022/3/23 22:56
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Page {
    /**
     *  当前页码
     */
    private Integer current = 1;
    /**
     *  显示上限
     */
    private Integer limit = 10;
    /**
     *  数据总数（用于计算总也页数）
     */
    private Integer rows;
    /**
     *  查询路径（用于复用分页链接）
     */
    private String path;

    public void setCurrent(Integer current) {
        if (current >= 1) {
            this.current = current;
        }
    }

    public void setLimit(Integer limit) {
        if (limit >= 1 && limit <= 20) {
            this.limit = limit;
        }
    }

    public void setRows(Integer rows) {
        if (rows >= 0) {
            this.rows = rows;
        }
    }

    /**
     * 获取当前页起始行
     * @return
     */
    public int getOffset() {
        // current * limit - limit
        return (current - 1) * limit;
    }

    /**
     * 获取总页数
     * @return
     */
    public int getTotal() {
        if (rows % limit == 0) {
            return rows / limit + 1;
        } else {
            return rows / limit + 1;
        }
    }

    /**
     * 获取起始页码
     * @return
     */
    public int getFrom() {
        int from = current - 2;
        return from < 1 ? 1 : from;
    }

    /**
     * 获取结束页码
     * @return
     */
    public int getTo() {
        int to = current + 2;
        int total = getTotal();
        return to > total ? total : to;
    }
}
```







## 过滤敏感词

使用前缀树来解决敏感词问题

![image-20220326163300207](https://gitee.com/xiaozhi-oos/save-img/raw/upload-img/image-20220326163300207.png)

```java
package com.newkewang.utils;

import org.apache.commons.lang3.CharUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;

/**
 * @author xiaozhi
 * @description 敏感词过滤器
 * @create 2022-03-2022/3/26 15:39
 */
@Component
public class SensitiveFilter{

    private static final Logger logger = LoggerFactory.getLogger(SensitiveFilter.class);

    // 替换符
    private static final String REPLACEMENT = "***";

    // 根节点
    private TrieNode rootNode = new TrieNode();

    @PostConstruct
    public void init() {
        try (
                InputStream is = this.getClass().getClassLoader().getResourceAsStream("sensitive-words.txt");
                BufferedReader reader = new BufferedReader(new InputStreamReader(is));
        ) {
            String keyword;
            while ((keyword = reader.readLine()) != null) {
                // 添加到前缀树
                this.addKeyword(keyword);
            }
        } catch (IOException e) {
            logger.error("加载敏感词文件失败: " + e.getMessage());
        }
    }

    // 将一个敏感词添加到前缀树中
    private void addKeyword(String keyword) {
        TrieNode tempNode = rootNode;
        for (int i = 0; i < keyword.length(); i++) {
            char c = keyword.charAt(i);
            TrieNode subNode = tempNode.getSubNode(c);

            if (subNode == null) {
                // 初始化子节点
                subNode = new TrieNode();
                tempNode.addSubNode(c, subNode);
            }

            // 指向子节点,进入下一轮循环
            tempNode = subNode;

            // 设置结束标识
            if (i == keyword.length() - 1) {
                tempNode.setKeywordEnd(true);
            }
        }
    }

    /**
     * 过滤敏感词
     *
     * @param text 待过滤的文本
     * @return 过滤后的文本
     */
    public String filter(String text) {
        if (StringUtils.isBlank(text)) {
            return null;
        }

        // 指针1
        TrieNode tempNode = rootNode;
        // 指针2
        int begin = 0;
        // 指针3
        int position = 0;
        // 结果
        StringBuilder sb = new StringBuilder();

        while (position < text.length()) {
            char c = text.charAt(position);

            // 跳过符号
            if (isSymbol(c)) {
                // 若指针1处于根节点,将此符号计入结果,让指针2向下走一步
                if (tempNode == rootNode) {
                    sb.append(c);
                    begin++;
                }
                // 无论符号在开头或中间,指针3都向下走一步
                position++;
                continue;
            }

            // 检查下级节点
            tempNode = tempNode.getSubNode(c);
            if (tempNode == null) {
                // 以begin开头的字符串不是敏感词
                sb.append(text.charAt(begin));
                // 进入下一个位置
                position = ++begin;
                // 重新指向根节点
                tempNode = rootNode;
            } else if (tempNode.isKeywordEnd()) {
                // 发现敏感词,将begin~position字符串替换掉
                sb.append(REPLACEMENT);
                // 进入下一个位置
                begin = ++position;
                // 重新指向根节点
                tempNode = rootNode;
            } else {
                // 检查下一个字符
                position++;
            }
        }

        // 将最后一批字符计入结果
        sb.append(text.substring(begin));

        return sb.toString();
    }

    // 判断是否为符号
    private boolean isSymbol(Character c) {
        // 0x2E80~0x9FFF 是东亚文字范围
        return !CharUtils.isAsciiAlphanumeric(c) && (c < 0x2E80 || c > 0x9FFF);
    }

    // 前缀树
    private class TrieNode {

        // 关键词结束标识
        private boolean isKeywordEnd = false;

        // 子节点(key是下级字符,value是下级节点)
        private Map<Character, TrieNode> subNodes = new HashMap<>();

        public boolean isKeywordEnd() {
            return isKeywordEnd;
        }

        public void setKeywordEnd(boolean keywordEnd) {
            isKeywordEnd = keywordEnd;
        }

        // 添加子节点
        public void addSubNode(Character c, TrieNode node) {
            subNodes.put(c, node);
        }

        // 获取子节点
        public TrieNode getSubNode(Character c) {
            return subNodes.get(c);
        }
    }

}
```





## 生成随机字符串

```java
public static String generateUUID() {
    return UUID.randomUUID().toString().replaceAll("-", "");
}
```





## 返回json字符串

```java
public static String getJsonString (int code, String msg, Map<String, Object> map) {
    JSONObject json = new JSONObject();
    json.put("code", code);
    json.put("msg", msg);
    if (map != null) {
        for (String key : map.keySet()) {
            json.put(key, map.get(key));
        }
    }
    return json.toJSONString();
}

public static String getJsonString(int code, String msg) {
    return getJsonString(code, msg, null);
}

public static String getJsonString(int code) {
    return getJsonString(code, null, null);
}

public static void main(String[] args) {
    Map<String, Object> map = new HashMap<>();
    map.put("name", "张三");
    map.put("age", 18);
    System.out.println(getJsonString(0, "ok", map));
}
```







# Kaptcha验证码使用

1	导入依赖

```xml
<dependency>
    <groupId>com.github.penggle</groupId>
    <artifactId>kaptcha</artifactId>
    <version>2.3.2</version>
</dependency>
```

2	设置验证码的配置并注入到容器中

```java
@Component
public class KaptchaConfig {
    @Bean
    public DefaultKaptcha getDefaultKaptcha(){
        com.google.code.kaptcha.impl.DefaultKaptcha defaultKaptcha = new com.google.code.kaptcha.impl.DefaultKaptcha();
        Properties properties = new Properties();
        properties.put("kaptcha.border", "no");
        properties.put("kaptcha.textproducer.font.color", "black");
        properties.put("kaptcha.image.width", "150");
        properties.put("kaptcha.image.height", "40");
        properties.put("kaptcha.textproducer.font.size", "30");
        properties.put("kaptcha.session.key", "verifyCode");
        properties.put("kaptcha.textproducer.char.space", "5");
        // 验证码个数
        properties.put("kaptcha.textproducer.char.length", "4");
        Config config = new Config(properties);
        defaultKaptcha.setConfig(config);

        return defaultKaptcha;
    }
}
```

3	获取验证码

```java
@Controller
public class CommonController {

    @Autowired
    private DefaultKaptcha captchaProducer;

    @GetMapping("/common/kaptcha")
    public void defaultKaptcha(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {
        byte[] captchaOutputStream = null;
        ByteArrayOutputStream imgOutputStream = new ByteArrayOutputStream();
        try {
            //生产验证码字符串并保存到session中
            String verifyCode = captchaProducer.createText();
            httpServletRequest.getSession().setAttribute("verifyCode", verifyCode);
            BufferedImage challenge = captchaProducer.createImage(verifyCode);
            ImageIO.write(challenge, "jpg", imgOutputStream);
        } catch (IllegalArgumentException e) {
            httpServletResponse.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
        captchaOutputStream = imgOutputStream.toByteArray();
        httpServletResponse.setHeader("Cache-Control", "no-store");
        httpServletResponse.setHeader("Pragma", "no-cache");
        httpServletResponse.setDateHeader("Expires", 0);
        httpServletResponse.setContentType("image/jpeg");
        ServletOutputStream responseOutputStream = httpServletResponse.getOutputStream();
        responseOutputStream.write(captchaOutputStream);
        responseOutputStream.flush();
        responseOutputStream.close();
    }
}
```

4	前端页面引用

```html
<img style="float: right;" alt="单击图片刷新！" class="pointer" th:src="@{/common/kaptcha}"
     onclick="this.src='/common/kaptcha?d='+new Date()*1">
```





# spring内置类库

## **断言**

1.  断言是一个逻辑判断，用于检查不应该发生的情况
2.  Assert 关键字在 JDK1.4 中引入，可通过 JVM 参数`-enableassertions`开启
3.  SpringBoot 中提供了 Assert 断言工具类，通常用于数据合法性检查

```java
// 要求参数 object 必须为非空（Not Null），否则抛出异常，不予放行
// 参数 message 参数用于定制异常信息。
void notNull(Object object, String message)
// 要求参数必须空（Null），否则抛出异常，不予『放行』。
// 和 notNull() 方法断言规则相反
void isNull(Object object, String message)
// 要求参数必须为真（True），否则抛出异常，不予『放行』。
void isTrue(boolean expression, String message)
// 要求参数（List/Set）必须非空（Not Empty），否则抛出异常，不予放行
void notEmpty(Collection collection, String message)
// 要求参数（String）必须有长度（即，Not Empty），否则抛出异常，不予放行
void hasLength(String text, String message)
// 要求参数（String）必须有内容（即，Not Blank），否则抛出异常，不予放行
void hasText(String text, String message)
// 要求参数是指定类型的实例，否则抛出异常，不予放行
void isInstanceOf(Class type, Object obj, String message)
// 要求参数 `subType` 必须是参数 superType 的子类或实现类，否则抛出异常，不予放行
void isAssignable(Class superType, Class subType, String message)
```

>   

## **对象、数组、集合**

### ObjectUtils

1.  获取对象的基本信息

```java
// 获取对象的类名。参数为 null 时，返回字符串："null" 
String nullSafeClassName(Object obj)
// 参数为 null 时，返回 0
int nullSafeHashCode(Object object)
// 参数为 null 时，返回字符串："null"
String nullSafeToString(boolean[] array)
// 获取对象 HashCode（十六进制形式字符串）。参数为 null 时，返回 0 
String getIdentityHexString(Object obj)
// 获取对象的类名和 HashCode。 参数为 null 时，返回字符串："" 
String identityToString(Object obj)
// 相当于 toString()方法，但参数为 null 时，返回字符串：""
String getDisplayString(Object obj)
```

1.  判断工具

```java
// 判断数组是否为空
boolean isEmpty(Object[] array)
// 判断参数对象是否是数组
boolean isArray(Object obj)
// 判断数组中是否包含指定元素
boolean containsElement(Object[] array, Object element)
// 相等，或同为 null时，返回 true
boolean nullSafeEquals(Object o1, Object o2)
/*
判断参数对象是否为空，判断标准为：
    Optional: Optional.empty()
       Array: length == 0
CharSequence: length == 0
  Collection: Collection.isEmpty()
         Map: Map.isEmpty()
 */
boolean isEmpty(Object obj)
```

1.  其他工具方法

```java
// 向参数数组的末尾追加新元素，并返回一个新数组
<A, O extends A> A[] addObjectToArray(A[] array, O obj)
// 原生基础类型数组 --> 包装类数组
Object[] toObjectArray(Object source)
```

### StringUtils

1.  字符串判断工具

```java
// 判断字符串是否为 null，或 ""。注意，包含空白符的字符串为非空
boolean isEmpty(Object str)
// 判断字符串是否是以指定内容结束。忽略大小写
boolean endsWithIgnoreCase(String str, String suffix)
// 判断字符串是否已指定内容开头。忽略大小写
boolean startsWithIgnoreCase(String str, String prefix) 
// 是否包含空白符
boolean containsWhitespace(String str)
// 判断字符串非空且长度不为 0，即，Not Empty
boolean hasLength(CharSequence str)
// 判断字符串是否包含实际内容，即非仅包含空白符，也就是 Not Blank
boolean hasText(CharSequence str)
// 判断字符串指定索引处是否包含一个子串。
boolean substringMatch(CharSequence str, int index, CharSequence substring)
// 计算一个字符串中指定子串的出现次数
int countOccurrencesOf(String str, String sub)
```

1.  字符串操作工具

```java
// 查找并替换指定子串
String replace(String inString, String oldPattern, String newPattern)
// 去除尾部的特定字符
String trimTrailingCharacter(String str, char trailingCharacter) 
// 去除头部的特定字符
String trimLeadingCharacter(String str, char leadingCharacter)
// 去除头部的空白符
String trimLeadingWhitespace(String str)
// 去除头部的空白符
String trimTrailingWhitespace(String str)
// 去除头部和尾部的空白符
String trimWhitespace(String str)
// 删除开头、结尾和中间的空白符
String trimAllWhitespace(String str)
// 删除指定子串
String delete(String inString, String pattern)
// 删除指定字符（可以是多个）
String deleteAny(String inString, String charsToDelete)
// 对数组的每一项执行 trim() 方法
String[] trimArrayElements(String[] array)
// 将 URL 字符串进行解码
String uriDecode(String source, Charset charset)
```

1.  路径相关工具方法

```java
// 解析路径字符串，优化其中的 “..” 
String cleanPath(String path)
// 解析路径字符串，解析出文件名部分
String getFilename(String path)
// 解析路径字符串，解析出文件后缀名
String getFilenameExtension(String path)
// 比较两个两个字符串，判断是否是同一个路径。会自动处理路径中的 “..” 
boolean pathEquals(String path1, String path2)
// 删除文件路径名中的后缀部分
String stripFilenameExtension(String path) 
// 以 “. 作为分隔符，获取其最后一部分
String unqualify(String qualifiedName)
// 以指定字符作为分隔符，获取其最后一部分
String unqualify(String qualifiedName, char separator)
```



### CollectionUtils

1.  集合判断工具

```java
// 判断 List/Set 是否为空
boolean isEmpty(Collection<?> collection)
// 判断 Map 是否为空
boolean isEmpty(Map<?,?> map)
// 判断 List/Set 中是否包含某个对象
boolean containsInstance(Collection<?> collection, Object element)
// 以迭代器的方式，判断 List/Set 中是否包含某个对象
boolean contains(Iterator<?> iterator, Object element)
// 判断 List/Set 是否包含某些对象中的任意一个
boolean containsAny(Collection<?> source, Collection<?> candidates)
// 判断 List/Set 中的每个元素是否唯一。即 List/Set 中不存在重复元素
boolean hasUniqueObject(Collection<?> collection)
```

1.  集合操作工具

```java
// 将 Array 中的元素都添加到 List/Set 中
<E> void mergeArrayIntoCollection(Object array, Collection<E> collection)  
// 将 Properties 中的键值对都添加到 Map 中
<K,V> void mergePropertiesIntoMap(Properties props, Map<K,V> map)
// 返回 List 中最后一个元素
<T> T lastElement(List<T> list)  
// 返回 Set 中最后一个元素
<T> T lastElement(Set<T> set) 
// 返回参数 candidates 中第一个存在于参数 source 中的元素
<E> E findFirstMatch(Collection<?> source, Collection<E> candidates)
// 返回 List/Set 中指定类型的元素。
<T> T findValueOfType(Collection<?> collection, Class<T> type)
// 返回 List/Set 中指定类型的元素。如果第一种类型未找到，则查找第二种类型，以此类推
Object findValueOfType(Collection<?> collection, Class<?>[] types)
// 返回 List/Set 中元素的类型
Class<?> findCommonElementType(Collection<?> collection)
```



## **文件、资源、IO 流**

### FileCopyUtils

1.  输入

```java
// 从文件中读入到字节数组中
byte[] copyToByteArray(File in)
// 从输入流中读入到字节数组中
byte[] copyToByteArray(InputStream in)
// 从输入流中读入到字符串中
String copyToString(Reader in)
```

1.  输出

```java
// 从字节数组到文件
void copy(byte[] in, File out)
// 从文件到文件
int copy(File in, File out)
// 从字节数组到输出流
void copy(byte[] in, OutputStream out) 
// 从输入流到输出流
int copy(InputStream in, OutputStream out) 
// 从输入流到输出流
int copy(Reader in, Writer out)
// 从字符串到输出流
void copy(String in, Writer out)
```

### ResourceUtils

1.  从资源路径获取文件

```java
// 判断字符串是否是一个合法的 URL 字符串。
static boolean isUrl(String resourceLocation)
// 获取 URL
static URL getURL(String resourceLocation) 
// 获取文件（在 JAR 包内无法正常使用，需要是一个独立的文件）
static File getFile(String resourceLocation)
```

1.  Resource

```java
// 文件系统资源 D:\...
FileSystemResource
// URL 资源，如 file://... http://...
UrlResource
// 类路径下的资源，classpth:...
ClassPathResource
// Web 容器上下文中的资源（jar 包、war 包）
ServletContextResource
// 判断资源是否存在
boolean exists()
// 从资源中获得 File 对象
File getFile()
// 从资源中获得 URI 对象
URI getURI()
// 从资源中获得 URI 对象
URL getURL()
// 获得资源的 InputStream
InputStream getInputStream()
// 获得资源的描述信息
String getDescription()
```



### StreamUtils 

1.  输入

```java
void copy(byte[] in, OutputStream out)
int copy(InputStream in, OutputStream out)
void copy(String in, Charset charset, OutputStream out)
long copyRange(InputStream in, OutputStream out, long start, long end)
```

1.  输出

```java
byte[] copyToByteArray(InputStream in)
String copyToString(InputStream in, Charset charset)
// 舍弃输入流中的内容
int drain(InputStream in) 
```



## **反射、AOP**

### ReflectionUtils

1.  获取方法

```java
// 在类中查找指定方法
Method findMethod(Class<?> clazz, String name) 
// 同上，额外提供方法参数类型作查找条件
Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes) 
// 获得类中所有方法，包括继承而来的
Method[] getAllDeclaredMethods(Class<?> leafClass) 
// 在类中查找指定构造方法
Constructor<T> accessibleConstructor(Class<T> clazz, Class<?>... parameterTypes) 
// 是否是 equals() 方法
boolean isEqualsMethod(Method method) 
// 是否是 hashCode() 方法 
boolean isHashCodeMethod(Method method) 
// 是否是 toString() 方法
boolean isToStringMethod(Method method) 
// 是否是从 Object 类继承而来的方法
boolean isObjectMethod(Method method) 
// 检查一个方法是否声明抛出指定异常
boolean declaresException(Method method, Class<?> exceptionType) 
```

1.  执行方法

```java
// 执行方法
Object invokeMethod(Method method, Object target)  
// 同上，提供方法参数
Object invokeMethod(Method method, Object target, Object... args) 
// 取消 Java 权限检查。以便后续执行该私有方法
void makeAccessible(Method method) 
// 取消 Java 权限检查。以便后续执行私有构造方法
void makeAccessible(Constructor<?> ctor) 
```

1.  获取字段

```java
// 在类中查找指定属性
Field findField(Class<?> clazz, String name) 
// 同上，多提供了属性的类型
Field findField(Class<?> clazz, String name, Class<?> type) 
// 是否为一个 "public static final" 属性
boolean isPublicStaticFinal(Field field) 
```

1.  设置字段

```java
// 获取 target 对象的 field 属性值
Object getField(Field field, Object target) 
// 设置 target 对象的 field 属性值，值为 value
void setField(Field field, Object target, Object value) 
// 同类对象属性对等赋值
void shallowCopyFieldState(Object src, Object dest)
// 取消 Java 的权限控制检查。以便后续读写该私有属性
void makeAccessible(Field field) 
// 对类的每个属性执行 callback
void doWithFields(Class<?> clazz, ReflectionUtils.FieldCallback fc) 
// 同上，多了个属性过滤功能。
void doWithFields(Class<?> clazz, ReflectionUtils.FieldCallback fc, 
                  ReflectionUtils.FieldFilter ff) 
// 同上，但不包括继承而来的属性
void doWithLocalFields(Class<?> clazz, ReflectionUtils.FieldCallback fc) 
```

### AopUtils

1.  判断代理类型

```java
// 判断是不是 Spring 代理对象
boolean isAopProxy()
// 判断是不是 jdk 动态代理对象
isJdkDynamicProxy()
// 判断是不是 CGLIB 代理对象
boolean isCglibProxy()
```

1.  获取被代理对象的 class

```java
// 获取被代理的目标 class
Class<?> getTargetClass()
```

### AopContext

1.  获取当前对象的代理对象

```java
Object currentProxy()
```





## Utils

### BeanUtils工具类

copyProperties(Object source, Object target)：将source中的属性值get到放入到target中的属性

**相当于**：target.setId(source.getId)





### HtmlUtils

可以防止xss攻击

转义html代码。比如说用户名是`<script>alter('哈哈')</script>`，这就会导致浏览器会执行这段代码，导致显示出现问题，那么我们可以使用HtmlUtils来防止这个问题出现，将对应的字符进行转义，让页面可以显示出来，而不是单纯的html代码

```java
// 转义HTML标记
HtmlUtils.htmlEscape("<script>alter('哈哈')</script>")
// 浏览器执行的是这一段代码   &lt;script&gt;alter(&#39;??&#39;)&lt;/script&gt;
```







# jsoup爬虫

## 1、导入依赖

```xml
<dependency>
    <groupId>org.jsoup</groupId>
    <artifactId>jsoup</artifactId>
    <version>1.13.1</version>
</dependency>
```



## 2、爬取数据

```java
public static List<JsoupData> jsoupGet() throws Exception {
    List<JsoupData> list = new ArrayList<JsoupData>();
    // 网址
    String url = "https://search.jd.com/Search?keyword=java";
    // 解析网页。 Jsoup返回Document就是浏览器Document对象
    Document document = Jsoup.parse(new URL(url), 30000);
    Element element = document.getElementById("J_goodsList");
    // 获取所有的li元素
    Elements elements = element.getElementsByTag("li");
    // 遍历每一个标签
    for (Element el : elements) {
        String img = el.getElementsByTag("img").eq(0).attr("data-lazy-img");
        String price = el.getElementsByClass("p-price").eq(0).text();
        String title = el.getElementsByClass("p-name").eq(0).text();
        // 将数据封装到数据中
        JsoupData jsoupData = new JsoupData(null,img, price, title);
        // 放到集合中
        list.add(jsoupData);
    }
    return list;
}
```



## 3、爬取图片到本地

```java
public static void downImages(String filePath, String imgUrl) {
    // 若指定文件夹没有，则先创建
    File dir = new File(filePath);
    if (!dir.exists()) {
        dir.mkdirs();
    }
    // 截取图片文件名
    String fileName = imgUrl.substring(imgUrl.lastIndexOf('/') + 1, imgUrl.length());

    try {
        // 文件名里面可能有中文或者空格，所以这里要进行处理。但空格又会被URLEncoder转义为加号
        String urlTail = URLEncoder.encode(fileName, "UTF-8");
        // 因此要将加号转化为UTF-8格式的%20
        imgUrl = imgUrl.substring(0, imgUrl.lastIndexOf('/') + 1) + urlTail.replaceAll("\\+", "\\%20");

    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    }
    // 写出的路径
    File file = new File(filePath + File.separator + fileName);

    try {
        // 获取图片URL
        URL url = new URL(imgUrl);
        // 获得连接
        URLConnection connection = url.openConnection();
        // 设置10秒的相应时间
        connection.setConnectTimeout(10 * 1000);
        // 获得输入流
        InputStream in = connection.getInputStream();
        // 获得输出流
        BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));
        // 构建缓冲区
        byte[] buf = new byte[1024];
        int size;
        // 写入到文件
        while (-1 != (size = in.read(buf))) {
            out.write(buf, 0, size);
        }
        out.close();
        in.close();
    } catch (MalformedURLException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }

}
```





# 操作office文档

## POI

Apache POI是[Apache软件基金会](https://baike.baidu.com/item/Apache软件基金会)的开放源码函式库，POI提供API给Java程序对Microsoft Office格式档案读和写的功能。

**结构**：

-   HSSF － 提供读写[Microsoft Excel](https://baike.baidu.com/item/Microsoft Excel)格式档案的功能。
-   XSSF － 提供读写[Microsoft](https://baike.baidu.com/item/Microsoft) Excel [OOXML](https://baike.baidu.com/item/OOXML)格式档案的功能。
-   HWPF － 提供读写[Microsoft Word](https://baike.baidu.com/item/Microsoft Word)格式档案的功能。
-   HSLF － 提供读写Microsoft PowerPoint格式档案的功能。
-   HDGF － 提供读写[Microsoft Visio](https://baike.baidu.com/item/Microsoft Visio)格式档案的功能。



### 导入依赖

```xml
<!--操作03版本的Excel-->
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi</artifactId>
    <version>4.1.2</version>
</dependency>
<!--操作07版本的Excel-->
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi-ooxml</artifactId>
    <version>4.1.2</version>
</dependency>
<!--日期格式化工具-->
<dependency>
    <groupId>joda-time</groupId>
    <artifactId>joda-time</artifactId>
    <version>2.10.9</version>
</dependency>
```



Workbook的实现类

![image-20210208193516426](https://gitee.com/xiaozhi-oos/save-img/raw/upload-img/image-20210208193516426.png)



### **代码实现**

```java
public class ExcelWriteTest {
    String Path = "E:\\IDEAWorkspace\\OtherStudy\\POIAndEasyEcxel";
    // 测试03版本的Excel
    @Test
    public void testWrite03() throws Exception {
        // 1、创建一个工作簿
        Workbook workbook = new HSSFWorkbook();
        // 2、创建一个表
        Sheet sheet = workbook.createSheet();
        // 3、创建一个行
        Row row1 = sheet.createRow(0);    // 得到行对象
        // 4、 创建单元格   (1,1)
        Cell cell11 = row1.createCell(0);      // 创建一个单元格
        cell11.setCellValue("学习的时间");
        // (1,2)
        Cell cell12 = row1.createCell(1);
        cell12.setCellValue("2000");

        // 第二行
        Row row2 = sheet.createRow(1);
        Cell cell21 = row2.createCell(0);
        cell21.setCellValue("统计时间");
        Cell cell22 = row2.createCell(1);
        String time = new DateTime().toString("yyyy-MM-dd HH:mm:ss");
        cell22.setCellValue(time);

        // 5、生成一张表（IO流）
        FileOutputStream fileOutputStream = new FileOutputStream(Path + "统计表03.xls");
        // 输出
        workbook.write(fileOutputStream);
        // 关闭流
        fileOutputStream.close();
        System.out.println("统计表生成完毕");
    }
    // 测试07版本
    @Test
    public void testWrite07() throws Exception {
        // 1、创建一个工作簿
        Workbook workbook = new XSSFWorkbook();
        // 2、创建一个表
        Sheet sheet = workbook.createSheet();
        // 3、创建一个行
        Row row1 = sheet.createRow(0);    // 得到行对象
        // 4、 创建单元格   (1,1)
        Cell cell11 = row1.createCell(0);      // 创建一个单元格
        cell11.setCellValue("学习的时间");
        // (1,2)
        Cell cell12 = row1.createCell(1);
        cell12.setCellValue("2000");

        // 第二行
        Row row2 = sheet.createRow(1);
        Cell cell21 = row2.createCell(0);
        cell21.setCellValue("统计时间");
        Cell cell22 = row2.createCell(1);
        String time = new DateTime().toString("yyyy-MM-dd HH:mm:ss");
        cell22.setCellValue(time);

        // 5、生成一张表（IO流）
        FileOutputStream fileOutputStream = new FileOutputStream(Path + "统计表07.xlsx");
        // 输出
        workbook.write(fileOutputStream);
        // 关闭流
        fileOutputStream.close();
        System.out.println("统计表生成完毕");
    }
}
```

**小结**：①07和03版本的对象不一样

​		   ②文件结尾不一样，03的是xls，07的是xlsx





### 数据批量写入

#### 大文件写HSSF（03版本）

**缺点**：03版本最多只能65536行，超过了就会报异常

**优点**：过程中写入内存，不操作磁盘，最后一次性写入磁盘，速度快

**代码实现**

```java
@Test
public void testWrite03BigData() throws Exception {
    // 开始时间
    long start = System.currentTimeMillis();
    // 创建一个簿
    Workbook workbook = new HSSFWorkbook();
    // 创建一个表
    Sheet sheet = workbook.createSheet();
    // 创建单元格
    for (int rowNum = 0; rowNum < 65536; rowNum++) {
        Row row = sheet.createRow(rowNum);
        for (int cellNUm = 0; cellNUm < 10; cellNUm++) {
            Cell cell = row.createCell(cellNUm);
            cell.setCellValue(cellNUm);
        }
    }
    // 写入
    FileOutputStream fileOutputStream = new FileOutputStream(Path + "testWrite03BigData.xls");
    workbook.write(fileOutputStream);
    // 关闭输出
    workbook.close();
    // 结束时间
    long end = System.currentTimeMillis();
    System.out.println("消耗时间" + (end - start));
}
```



#### 大文件写XSSF（07版本）

07版本理论上是可以无限行

**缺点**：写数据时速度非常慢，非常耗内存，也会发生内存溢出，如100万条

**优点**：可以写入大量的数据，如20万条

**代码实现**

```java
@Test
public void testWrite07BigData() throws Exception {
    // 开始时间
    long start = System.currentTimeMillis();
    // 创建一个簿
    Workbook workbook = new XSSFWorkbook();
    // 创建一个表
    Sheet sheet = workbook.createSheet();
    // 创建单元格
    for (int rowNum = 0; rowNum < 100000; rowNum++) {
        Row row = sheet.createRow(rowNum);
        for (int cellNUm = 0; cellNUm < 10; cellNUm++) {
            Cell cell = row.createCell(cellNUm);
            cell.setCellValue(cellNUm);
        }
    }
    // 写入
    FileOutputStream fileOutputStream = new FileOutputStream(Path + "testWrite07BigData.xls");
    workbook.write(fileOutputStream);
    // 关闭输出
    workbook.close();
    // 结束时间
    long end = System.currentTimeMillis();
    System.out.println("消耗时间" + (end - start));
}
```



**大文件写入SXSSF（07版本的快速写入）**

**优点**：可以写非常大的数据量，入100万条甚至更多条，写数据速度快，占用更少内存

**注意**：过程中会产生临时文件，需要清理临时文件

==原理：默认由100条记录被保存到内存中，如果超过这数量，则最前面的数据写入临时文件，如果想自定义内存中数据的数量，可以使用new SXSSFWorkbook(数量)==

SXSSFWorkbook-来至官方的解释:实现"BigGridDemo"策略的流式XSSFWorkbook版本。这允许写入非常大的文件而不会耗尽内存,因为任何时候只有可配置的行部分被保存在内存中。

请注意,仍然可能会消耗大量内存,这些内存基于您正在使用的功能,例如合并区域,注....仍然只存储在内存中,因此如果广泛使用,可能需要大量内存。

**代码实现**

```java
// 进阶版
@Test
public void testWrite07BigDataS() throws Exception {
    // 开始时间
    long start = System.currentTimeMillis();
    // 创建一个簿
    Workbook workbook = new SXSSFWorkbook();
    // 创建一个表
    Sheet sheet = workbook.createSheet();
    // 创建单元格
    for (int rowNum = 0; rowNum < 200000; rowNum++) {
        Row row = sheet.createRow(rowNum);
        for (int cellNUm = 0; cellNUm < 10; cellNUm++) {
            Cell cell = row.createCell(cellNUm);
            cell.setCellValue(cellNUm);
        }
    }
    // 写入
    FileOutputStream fileOutputStream = new FileOutputStream(Path + "testWrite07BigDataS.xls");
    workbook.write(fileOutputStream);
    // 关闭输出
    workbook.close();
    // 清楚临时文件
    ((SXSSFWorkbook) workbook).dispose();
    // 结束时间
    long end = System.currentTimeMillis();
    System.out.println("消耗时间" + (end - start));
}
```





### 读取文件

#### 代码实现

03版本

```java
@Test
public void testRead03() throws Exception{
    // 获取文件流
    FileInputStream fileInputStream = new FileInputStream(Path + "统计表03.xls");
    // 1、创建一个工作簿。   Excel能操作的这里也可以操作
    Workbook workbook = new HSSFWorkbook(fileInputStream);
    // 2、得到表
    Sheet sheet = workbook.getSheetAt(0);   // 通过下角标的方式获取表
    // 3、得到行
    Row row = sheet.getRow(0);
    // 4、得到列
    Cell cell = row.getCell(1);
    // 获取字符串类型
    System.out.println(cell.getStringCellValue());
    // 关闭流
    fileInputStream.close();
}
```

07版本

```java
@Test
public void testRead07() throws Exception{
    // 获取文件流
    FileInputStream fileInputStream = new FileInputStream(Path + "统计表07.xlsx");
    // 1、创建一个工作簿。   Excel能操作的这里也可以操作
    Workbook workbook = new XSSFWorkbook(fileInputStream);
    // 2、得到表
    Sheet sheet = workbook.getSheetAt(0);   // 通过下角标的方式获取表
    // 3、得到行
    Row row = sheet.getRow(1);
    // 4、得到列
    Cell cell = row.getCell(1);
    // 获取字符串类型
    System.out.println(cell.getStringCellValue());
    // 关闭流
    fileInputStream.close();
}
```

==注意：不同的值用不同的类型接收==



#### 读取不同的数据类型

```java
// 读取不同类型
@Test
public void testCellType() throws Exception {
    // 获取文件流
    FileInputStream fileInputStream = new FileInputStream(Path + "明细表.xls");
    // 创建工作簿
    Workbook workbook = new HSSFWorkbook(fileInputStream);
    // 创建表
    Sheet sheet = workbook.getSheetAt(0);
    // 获取标题内容
    Row rowTitle = sheet.getRow(0);
    if (rowTitle != null) {
        int cellCount = rowTitle.getPhysicalNumberOfCells();    // 列数
        for (int cellNum = 0; cellNum < cellCount; cellNum++) {
            Cell cell = rowTitle.getCell(cellNum);  // 获取一列的每个单元格
            // 单元格不等于null
            if (cell != null) {
                CellType cellType = cell.getCellType();
                String cellValue = cell.getStringCellValue();
                System.out.print(cellValue + " | ");
            }
        }
        System.out.println();
    }

    // 读取表中的内容
    int rowCount = sheet.getPhysicalNumberOfRows();
    for (int rowNum = 0; rowNum < rowCount; rowNum++) {
        Row rowData = sheet.getRow(rowNum);
        if (rowData != null) {
            // 读取列
            int cellCount = rowTitle.getPhysicalNumberOfCells();
            for (int cellNum = 0; cellNum < cellCount; cellNum++) {
                System.out.print("[" + (rowNum + 1) + "-" + (cellNum + 1) + "]");

                Cell cell = rowData.getCell(cellNum);
                if (cell != null) {
                    CellType cellType = cell.getCellType();
                    String cellValue = "";
                    switch (cellType) {
                        case STRING:    // 字符串
                            System.out.print("【字符串】");
                            cellValue = cell.getStringCellValue();
                            break;
                        case BOOLEAN:    // 布尔
                            System.out.print("【布尔】");
                            cellValue = String.valueOf(cell.getBooleanCellValue());
                            break;
                        case BLANK:    // 空
                            System.out.print("【空】");
                            break;
                        case NUMERIC:    // 数字（日期、普通数字）
                            System.out.print("【NUMERIC】");
                            if (HSSFDateUtil.isCellDateFormatted(cell)) {   // 日期
                                System.out.print("【日期】");
                                Date date = cell.getDateCellValue();
                                cellValue = new DateTime(date).toString("yyyy-MM-dd");
                            } else {
                                // 不是日期格式，防止数字过长
                                System.out.println("【转换为字符串输出】");
                                cellValue = cell.toString();
                            }
                            break;
                        case ERROR:
                            System.out.println("【数据类型错误】");
                            break;
                    }
                    System.out.println(cellValue);
                }
            }
        }
    }
    fileInputStream.close();
}
```





## EasyExcel

EasyExcel是一个基于Java的简单、省内存的读写Excel的开源项目。在尽可能节约内存的情况下支持读写百M的Excel。 github地址:https://github.com/alibaba/easyexcel



### 写入数据

1、首先创建一个格式类，就是对应的列

```java
@Data
public class DemoData {
    @ExcelProperty("字符串标题")
    private String string;
    @ExcelProperty("日期标题")
    private Date date;
    @ExcelProperty("数字标题")
    private Double doubleData;
    /**
     * 忽略这个字段
     */
    @ExcelIgnore
    private String ignore;
}
```

2、创建一个处理业务逻辑的类

```java
public class EasyTest {
    private List<DemoData> data() {
        // 写入的逻辑代码
        List<DemoData> list = new ArrayList<DemoData>();
        for (int i = 0; i < 10; i++) {
            DemoData data = new DemoData();
            data.setString("字符串" + i);
            data.setDate(new Date());
            data.setDoubleData(0.56);
            list.add(data);
        }
        return list;
    }
}
```

3、测试

```java
@Test
public void simpleWrite() {
    // 写法1
    String Path = "E:\\IDEAWorkspace\\OtherStudy\\POIAndEasyEcxel\\";
    String fileName = Path + "EasyTest.xlsx";
    // 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭
    // 如果这里想使用03 则 传入excelType参数即可
    // write(文件名，格式类)
    // sheet（表名）
    // doWrite(数据)
    EasyExcel.write(fileName, DemoData.class).sheet("模板").doWrite(data());
}
```



### 读入数据

1、创建一个格式类

```java
@Data
public class DemoData {
    private String string;
    private Date date;
    private Double doubleData;
}
```

2、创建监听器类

```java
// 有个很重要的点 DemoDataListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去
public class DemoDataListener extends AnalysisEventListener<DemoData> {
    private static final Logger LOGGER = LoggerFactory.getLogger(DemoDataListener.class);
    /**
     * 每隔5条存储数据库，实际使用中可以3000条，然后清理list ，方便内存回收
     */
    private static final int BATCH_COUNT = 5;
    List<DemoData> list = new ArrayList<DemoData>();
    /**
     * 假设这个是一个DAO，当然有业务逻辑这个也可以是一个service。当然如果不用存储这个对象没用。
     */
    private DemoDAO demoDAO;
    public DemoDataListener() {
        // 这里是demo，所以随便new一个。实际使用如果到了spring,请使用下面的有参构造函数
        demoDAO = new DemoDAO();
    }
    /**
     * 如果使用了spring,请使用这个构造方法。每次创建Listener的时候需要把spring管理的类传进来
     *
     * @param demoDAO
     */
    public DemoDataListener(DemoDAO demoDAO) {
        this.demoDAO = demoDAO;
    }
    /**
     * 这个每一条数据解析都会来调用
     *
     * @param data
     *            one row value. Is is same as {@link AnalysisContext#readRowHolder()}
     * @param context
     */
    @Override
    public void invoke(DemoData data, AnalysisContext context) {
        LOGGER.info("解析到一条数据:{}", JSON.toJSONString(data));
        list.add(data);
        // 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM
        if (list.size() >= BATCH_COUNT) {
            saveData();
            // 存储完成清理 list
            list.clear();
        }
    }
    /**
     * 所有数据解析完成了 都会来调用
     *
     * @param context
     */
    @Override
    public void doAfterAllAnalysed(AnalysisContext context) {
        // 这里也要保存数据，确保最后遗留的数据也存储到数据库
        saveData();
        LOGGER.info("所有数据解析完成！");
    }
    /**
     * 加上存储数据库
     */
    private void saveData() {
        LOGGER.info("{}条数据，开始存储数据库！", list.size());
        demoDAO.save(list);
        LOGGER.info("存储数据库成功！");
    }
}
```

3、定义读到哪里展示

这里是保存到数据库中

```java
/**
 * 假设这个是你的DAO存储。当然还要这个类让spring管理，当然你不用需要存储，也不需要这个类。
 **/
public class DemoDAO {
    public void save(List<DemoData> list) {
        // 如果是mybatis,尽量别直接调用多次insert,自己写一个mapper里面新增一个方法batchInsert,所有数据一次性插入
    }
}
```



==**注意**：数据是被读到了list集合中，找到对应的方法进行输出就可以输出到控制台展示==



### 第二次学习

#### 写入数据

①创建一个实体类

```java
@Data
public class UserData {

    @ExcelProperty("用户编号")
    private Integer uid;

    @ExcelProperty("用户名称")
    private String username;
}
```



②进行测试

```java
public class TestWrite {

    public static void main(String[] args) {
        // 构建数据list集合
        List<UserData> list = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            UserData userData = new UserData();
            userData.setUid(i);
            userData.setUsername("xiaozhi" + i);
            list.add(userData);
        }
        // 设置excel文件路径和文件名称
        String fileName= "E:\\testEasyExcel\\1.xlsx";

        // 调用方法实现写操作
        EasyExcel.write(fileName,UserData.class).sheet("用户信息")
                .doWrite(list);
    }
}
```



#### 读入数据

①创建一个实体类

```java
@Data
public class UserData {

    @ExcelProperty(value = "用户编号",index = 0)
    private Integer uid;

    // index是对应的位置
    @ExcelProperty(value = "用户名称",index = 1)
    private String username;
}
```



②创建一个监听器

```java
public class ExcelListener extends AnalysisEventListener<UserData> {

    // 一行一行读取excel内容，从第二行开始读取，封装到对象中
    @Override
    public void invoke(UserData userData, AnalysisContext analysisContext) {
        System.out.println(userData);
    }

    // 读取表头中的内容
    @Override
    public void invokeHead(Map<Integer, CellData> headMap, AnalysisContext context) {
        System.out.println("表头信息" + headMap);
    }

    // 读取之后执行
    @Override
    public void doAfterAllAnalysed(AnalysisContext analysisContext) {

    }
}
```



③测试

```java
public class TestRead {

    public static void main(String[] args) {
        // 读取文件路径
        String fileName= "E:\\testEasyExcel\\1.xlsx";

        // 调用方法实现读操作
        EasyExcel.read(fileName,UserData.class,new ExcelListener()).sheet().doRead();
    }
}
```











# Hutool

## 自定义util

```java
public class RegexUtils {
    /**
     * 是否是无效手机格式
     * @param phone 要校验的手机号
     * @return true:符合，false：不符合
     */
    public static boolean isPhoneInvalid(String phone){
        return mismatch(phone, RegexPatterns.PHONE_REGEX);
    }
    /**
     * 是否是无效邮箱格式
     * @param email 要校验的邮箱
     * @return true:符合，false：不符合
     */
    public static boolean isEmailInvalid(String email){
        return mismatch(email, RegexPatterns.EMAIL_REGEX);
    }

    /**
     * 是否是无效验证码格式
     * @param code 要校验的验证码
     * @return true:符合，false：不符合
     */
    public static boolean isCodeInvalid(String code){
        return mismatch(code, RegexPatterns.VERIFY_CODE_REGEX);
    }

    // 校验是否不符合正则格式
    private static boolean mismatch(String str, String regex){
        if (StrUtil.isBlank(str)) {
            return true;
        }
        return !str.matches(regex);
    }
}
```





## BeanUtil

copyProperties方法：将对象相同名字的属性进行赋值，比如user和userDto

beanToMap：将bean转换成map存储

fillBeanwithMap：将map转成bean







## RandomUtil

randomNumbers方法：生成指定数量的随机数字

randomString()：生成指定数量的随机字符串

以此类推....





## UUID

randomUUID：随机生成字符串

















# Guava













# Apache Commons

## commons-lang3







# Lombok的使用

## 自动生成方法

### @Data

自动生成Getter、Setter、toString方法



### @NoArgsConstructor

空参构造器



### @AllArgsConstructor

所有参构造器



### @ToString

toString方法



### @EqualsAndHashCode

见名知意





## 日志嵌入

### @Slf4j

标注这个注解就可以使用`log`变量来输出日志





## 异常处理

### @SneakyThrows

在我们已知异常可以处理的情况下，我们可以不用使用try-catch来捕获异常，可以使用这个注解来捕获异常，代码就会变得非常简洁

-   **可以使用的情况：**

    eg：springBoot项目中做了全局异常处理，那么就可以使用这个注解来进行捕获

-   **不能使用的情况**：

    eg：你在捕获异常的时候需要进行某些操作

























