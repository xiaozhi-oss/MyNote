# 尚医通介绍和环境搭建

## 介绍

### 简介

尚医通即为网上预约挂号系统，网上预约挂号是近年来开展的一项便民就医服务，旨在缓解看病难、挂号难的就医难题，许多患者为看一次病要跑很多次医院，最终还不一定能保证看得上医生。网上预约挂号全面提供的预约挂号业务从根本上解决了这一就医难题。随时随地轻松挂号！不用排长队！



### 核心技术

SpringBoot：简化新Spring应用的初始搭建以及开发过程

SpringCloud：基于Spring Boot实现的云原生应用开发工具，SpringCloud使用的技术：（SpringCloudGateway、Spring Cloud Alibaba Nacos、Spring Cloud Alibaba Sentinel、SpringCloud Task和SpringCloudFeign等）

MyBatis-Plus：持久层框架

Redis：内存缓存

RabbitMQ：消息中间件

HTTPClient: Http协议客户端

Swagger2：Api接口文档工具

Nginx：负载均衡

Lombok

Mysql：关系型数据库

MongoDB：面向文档的NoSQL数据库

 

Vue.js：web 界面的渐进式框架

Node.js： JavaScript 运行环境

Axios：Axios 是一个基于 promise 的 HTTP 库

NPM：包管理器

Babel：转码器

Webpack：打包工具

Docker ：容器技术

Git：代码管理工具



### 业务流程

![尚医通业务流程](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/尚医通业务流程-1620131342891.png)

### 服务架构

![尚医通架构图](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/尚医通架构图.png)



### 文件结构

hospital-manage：医院接口模拟端（已开发，直接使用）

yygh-parent：根目录，管理子模块：

​	common：公共模块父节点

​		common-util：工具类模块，所有模块都可以依赖于它

​		rabbit-util：rabbitmq业务封装

​		service-util：service服务的工具包，包含service服务的公共配置类，所有              service模块依赖于它

​	server-gateway：服务网关

​	model：实体类模块

​	service：api接口服务父节点

​		service-hosp：医院api接口服务

​		service-cmn：公共api接口服务

​		service-user：用户api接口服务

​		service-order：订单api接口服务

​		service-oss：文件api接口服务

​		service-sms：短信 api接口服务

​		service-task：定时任务服务

​		service-statistics：统计api接口服务

​	service-client：feign服务调用父节点

​		service-cmn-client：公共api接口

​		service-hosp-client：医院api接口

​		service-order-client：订单api接口

service-user：用户api接口

**整个项目结构**

![image-20210504203357444](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210504203357444.png)

![image-20210504203413208](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210504203413208.png)



## 搭建环境和医院设置

### 预约挂号微服务模块搭建

### 1	构建父工程（yygh-parent）

#### ①创建一个空的springBoot项目

#### ②添加配置pom.xml

把项目中的大部分替换成我们自己的

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <modules>
        <module>common</module>
        <module>model</module>
        <module>service</module>
        <module>server-gateway</module>
        <module>service-client</module>
        <module>hospital-manage</module>
    </modules>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.2.1.RELEASE</version>
    </parent>

    <groupId>com.atguigu.yygh</groupId>
    <artifactId>yygh-parent</artifactId>
    <version>1.0</version>
    <packaging>pom</packaging>

    <properties>
        <java.version>1.8</java.version>
        <cloud.version>Hoxton.RELEASE</cloud.version>
        <alibaba.version>2.2.0.RELEASE</alibaba.version>
        <mybatis-plus.version>3.3.1</mybatis-plus.version>
        <mysql.version>5.1.46</mysql.version>
        <swagger.version>2.7.0</swagger.version>
        <jwt.version>0.7.0</jwt.version>
        <fastjson.version>1.2.29</fastjson.version>
        <httpclient.version>4.5.1</httpclient.version>
        <easyexcel.version>2.2.0-beta2</easyexcel.version>
        <aliyun.version>4.1.1</aliyun.version>
        <oss.version>3.9.1</oss.version>
        <jodatime.version>2.10.1</jodatime.version>
    </properties>

    <!--配置dependencyManagement锁定依赖的版本-->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>${alibaba.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!--mybatis-plus 持久层-->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
                <version>${mybatis-plus.version}</version>
            </dependency>

            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <version>${mysql.version}</version>
            </dependency>

            <!--swagger-->
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger2</artifactId>
                <version>${swagger.version}</version>
            </dependency>
            <!--swagger ui-->
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger-ui</artifactId>
                <version>${swagger.version}</version>
            </dependency>

            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt</artifactId>
                <version>${jwt.version}</version>
            </dependency>

            <dependency>
                <groupId>org.apache.httpcomponents</groupId>
                <artifactId>httpclient</artifactId>
                <version>${httpclient.version}</version>
            </dependency>

            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>fastjson</artifactId>
                <version>${fastjson.version}</version>
            </dependency>

            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>easyexcel</artifactId>
                <version>${easyexcel.version}</version>
            </dependency>

            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>aliyun-java-sdk-core</artifactId>
                <version>${aliyun.version}</version>
            </dependency>

            <dependency>
                <groupId>com.aliyun.oss</groupId>
                <artifactId>aliyun-sdk-oss</artifactId>
                <version>${oss.version}</version>
            </dependency>

            <!--日期时间工具-->
            <dependency>
                <groupId>joda-time</groupId>
                <artifactId>joda-time</artifactId>
                <version>${jodatime.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
```



### 2	搭建common父模块

common：公共模块父节点

​	common-util：工具类模块，所有模块都可以依赖于它

​	service-util：service服务的工具包，包含service服务的公共配置类，所有service模块依赖于它



#### ①搭建common

点击yygh-parent，选择New–>Module,操作如下

![image-20210504204201389](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210504204201389.png)

选择下一步

![image-20210504204215665](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210504204215665.png)

![image-20210504204222525](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210504204222525.png)

完成，删除src目录，结构如下

![image-20210504204234090](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210504204234090.png)

#### ②修改配置pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>com.atguigu.yygh</groupId>
        <artifactId>yygh-parent</artifactId>
        <version>1.0</version>
    </parent>

    <artifactId>common</artifactId>
    <packaging>pom</packaging>
    <version>1.0</version>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <scope>provided </scope>
        </dependency>

        <!--mybatis-plus-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <scope>provided </scope>
        </dependency>

        <!--lombok用来简化实体类：需要安装lombok插件-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>

        <!--swagger-->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
        </dependency>
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
        </dependency>
    </dependencies>
</project>
```



### 3	搭建common-util模块

#### ①搭建common-util

点击common，选择New–>Module,操作如下

![image-20210504204334221](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210504204334221.png)

选择下一步

![image-20210504204342583](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210504204342583.png)

选择下一步

![image-20210504204352921](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210504204352921.png)

完成，结构如下

![image-20210504204405860](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210504204405860.png)

#### ②修改配置pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.atguigu.yygh</groupId>
        <artifactId>common</artifactId>
        <version>1.0</version>
    </parent>

    <artifactId>common-util</artifactId>
    <version>1.0</version>

    <packaging>jar</packaging>
    <name>common-util</name>
    <description>common-util</description>

    <dependencies>
        <dependency>
            <groupId>org.apache.httpcomponents</groupId>
            <artifactId>httpclient</artifactId>
        </dependency>

        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
        </dependency>

        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt</artifactId>
        </dependency>

        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>easyexcel</artifactId>
        </dependency>

        <!-- 日期工具栏依赖 -->
        <dependency>
            <groupId>joda-time</groupId>
            <artifactId>joda-time</artifactId>
        </dependency>
    </dependencies>

</project>
```

#### ③添加公共工具类

![image-20210504204451543](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210504204451543.png)

| `YyghException` | 自定义全局异常          |
| --------------- | ----------------------- |
| Result          | API统一返回结果封装类   |
| ResultCodeEnum  | API统一返回结果状态信息 |
| BeanUtils       | 实体bean copy工具类     |
| `MD5`           | MD5加密工具类           |



### 4	搭建service-util模块

#### ①搭建service-util

搭建过程同common-util，如下图

![image-20210504204612225](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210504204612225.png)

#### ②修改配置pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.atguigu.yygh</groupId>
        <artifactId>common</artifactId>
        <version>1.0</version>
    </parent>

    <artifactId>service-util</artifactId>
    <version>1.0</version>

    <packaging>jar</packaging>
    <name>service-util</name>
    <description>service-util</description>
    <dependencies>
        <dependency>
            <groupId>com.atguigu.yygh</groupId>
            <artifactId>common-util</artifactId>
            <version>1.0</version>
        </dependency>
        <!-- redis -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <!-- spring2.X集成redis所需common-pool2-->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
            <version>2.6.0</version>
        </dependency>
    </dependencies>
</project>
```



#### ③添加service-util公共类

![image-20210504204703857](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210504204703857.png)

| `MybatisPlusConfig`       | MybatisPlus配置类          |
| ------------------------- | -------------------------- |
| `CommonMetaObjectHandler` | Mybatis plus Handler配置类 |



### 5	搭建model模块

#### ①搭建过程同common-util父模块

#### ②修改配置pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>com.atguigu.yygh</groupId>
        <artifactId>yygh-parent</artifactId>
        <version>1.0</version>
    </parent>

    <artifactId>model</artifactId>
    <version>1.0</version>
    <packaging>jar</packaging>
    <name>model</name>
    <description>model</description>
    <dependencies>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
        <!--mybatis-plus-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <scope>provided </scope>
        </dependency>
        <!--swagger-->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <scope>provided </scope>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>easyexcel</artifactId>
            <scope>provided </scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-mongodb</artifactId>
            <scope>provided </scope>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <scope>provided </scope>
        </dependency>
    </dependencies>
</project>
```



#### ③引入实体类

将实体类都引入进来，后续不再单独引入，实体类没有业务逻辑，提前引入，方便后续开发。



### 6	搭建service父模块

service：service模块父节点

service-user：会员服务模块

...

#### ①搭建service

搭建过程同common父模块

#### ②修改配置pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>yygh-parent</artifactId>
        <groupId>com.atguigu.yygh</groupId>
        <version>1.0</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>service</artifactId>
    <packaging>pom</packaging>
    <version>1.0</version>
    <dependencies>
        <dependency>
            <groupId>com.atguigu.yygh</groupId>
            <artifactId>service-util</artifactId>
            <version>1.0</version>
        </dependency>
        <dependency>
            <groupId>com.atguigu.yygh</groupId>
            <artifactId>model</artifactId>
            <version>1.0</version>
        </dependency>
        <!--web-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!--mybatis-plus-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
        </dependency>
        <!--mysql-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
        <!--开发者工具-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <optional>true</optional>
        </dependency>
        <!--当前阶段先不引入-->
<!--        &lt;!&ndash; 服务调用feign &ndash;&gt;-->
<!--        <dependency>-->
<!--            <groupId>org.springframework.cloud</groupId>-->
<!--            <artifactId>spring-cloud-starter-openfeign</artifactId>-->
<!--        </dependency>-->
<!--        &lt;!&ndash; 服务注册 &ndash;&gt;-->
<!--        <dependency>-->
<!--            <groupId>com.alibaba.cloud</groupId>-->
<!--            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>-->
<!--        </dependency>-->
<!--        &lt;!&ndash; 流量控制 &ndash;&gt;-->
<!--        <dependency>-->
<!--            <groupId>com.alibaba.cloud</groupId>-->
<!--            <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>-->
<!--        </dependency>-->
    </dependencies>
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.yml</include>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
                <filtering>false</filtering>
            </resource>
            <resource>
                <directory>src/main/resources</directory>
                <includes> <include>**/*.yml</include>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
                <filtering>false</filtering>
            </resource>
        </resources>
    </build>
</project>
```





## gitee使用

1	新创建一个仓库，仓库名和我们的项目名一致

2	提交代码push到我们创建好的仓库

![image-20210504210256506](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210504210256506.png)

![image-20210504210324253](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210504210324253.png)

可以看到我们的代码已经push到了gitee上了



# 医院设置模块开发

## 1	医院设置需求

#### ①需求

医院设置主要是用来保存开通医院的一些基本信息，每个医院一条信息，保存了医院编号（平台分配，全局唯一）和接口调用相关的签名key等信息，是整个流程的第一步，只有开通了医院设置信息，才可以上传医院相关信息。

我们所开发的功能就是基于单表的一个CRUD、锁定/解锁和发送签名信息这些基本功能。



#### ②表结构

![image-20210505111139860](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210505111139860.png)

hosname：医院名称

hoscode：医院编号（平台分配，全局唯一，api接口必填信息）

api_url：医院回调的基础url（如：预约下单，我们要调用该地址去医院下单）

sign_key：双方api接口调用的签名key，有平台生成

contacts_name：医院联系人姓名

contacts_phone：医院联系人手机

status：状态（锁定/解锁）



## 2	搭建医院模块service-hosp

### 1	搭建service-hosp

#### ①搭建模块

在service模块创建一个子模块service-hosp

![image-20210505111725037](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210505111725037.png)

#### ②修改配置

1、修改pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>service</artifactId>
        <groupId>com.xiaozhi</groupId>
        <version>1.0</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>
    
    <version>1.0</version>
    <artifactId>service-hosp</artifactId>
    <packaging>jar</packaging>
    <name>service-hosp</name>
    <description>service-hosp</description>

    <dependencies>
    </dependencies>

    <build>
        <finalName>service-hosp</finalName>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```

2、添加配置文件application.properties

```properties
# 服务端口
server.port=8201
# 服务名
spring.application.name=service-hosp

# 环境设置：dev、test、prod
spring.profiles.active=dev

# mysql数据库连接
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/yygh_hosp?characterEncoding=utf-8&useSSL=false
spring.datasource.username=root
spring.datasource.password=root

#返回json的全局时间格式
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8

#配置mapper xml文件的路径
#mybatis-plus.mapper-locations=classpath:com/xiaozhi/yygh/mapper/xml/*.xml
mybatis-plus.mapper-locations=classpath:com/xiaozhi/yygh/hosp/mapper/xml/*.xml
# nacos服务地址
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848

#开启sentinel
feign.sentinel.enabled=true
#设置sentinel地址
spring.cloud.sentinel.transport.dashboard=http://127.0.0.1:8858

#mongodb地址
spring.data.mongodb.host=192.168.44.163
spring.data.mongodb.port=27017
spring.data.mongodb.database=yygh_hosp

#rabbitmq地址
spring.rabbitmq.host=127.0.0.1
spring.rabbitmq.port=5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
```



### 2	添加启动类

```java
@SpringBootApplication
public class ServiceHospApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceHospApplication.class,args);
    }
}
```



### 3	搭建mapper和service

#### ①添加model

**说明**：由于实体对象没有逻辑，我们统一导入，放入到我们moudle模块中，文件在资料中

![image-20210505113338755](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210505113338755.png)

进入到实体类中查看

![image-20210505113729672](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210505113729672.png)

所有实体类都继承这个类，BaseEntity封住了所以实体类都有的属性

```java
@Data
public class BaseEntity implements Serializable {

    @ApiModelProperty(value = "id")
    @TableId(type = IdType.AUTO)
    private Long id;

    @ApiModelProperty(value = "创建时间")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @TableField("create_time")
    private Date createTime;

    @ApiModelProperty(value = "更新时间")
    @TableField("update_time")
    private Date updateTime;

    @ApiModelProperty(value = "逻辑删除(1:已删除，0:未删除)")
    @TableLogic
    @TableField("is_deleted")
    private Integer isDeleted;

    @ApiModelProperty(value = "其他参数")
    @TableField(exist = false)
    private Map<String,Object> param = new HashMap<String,Object>();
}
```



#### ②添加Mapper

添加HospitalSetMapper接口

![image-20210505114248523](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210505114248523.png)

```java
@Mapper
public interface HospitalSetMapper extends BaseMapper<HospitalSet> {

}
```

我们还要将moudel引进来，在service模块中引入

```xml
<dependency>
    <groupId>com.xiaozhi</groupId>
    <artifactId>model</artifactId>
    <version>1.0</version>
</dependency>
```

在mapper/xml下添加HospitalSetMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
      "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.xiaozhi.yygh.hosp.mapper.HospitalSetMapper">

</mapper>
```



#### ③添加service接口及实现类

1、添加com.atguigu.yygh.hosp.service.HospitalSetService接口

```java
package com.xiaozhi.yygh.hosp.service;

import com.baomidou.mybatisplus.extension.service.IService;

/**
 * @author xiaozhi
 * @description
 * @create 2021-05-2021/5/5 13:13
 */
public interface HospitalSetService extends IService<HospitalSet> {
    
}
```

**说明**：Iservice是mp中的接口，它封装了一些常用的方法

2、添加com.atguigu.yygh.hosp.service.impl.HospitalSetServiceImpl接口实现

```java
package com.xiaozhi.yygh.hosp.service.impl;

@Service
public class HospitalSetServiceImpl extends ServiceImpl<HospitalSetMapper, HospitalSet>implements HospitalSetService {
	
}
```

说明：我们不需要引入HospitalMapper，因为ServiceImpl底层帮我们引入了

![image-20210505134705263](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210505134705263.png)



#### ④添加controller

添加com.xiaozhi.yygh.hosp.controller.HospitalSetController类

```java
@RestController
public class HospitalSetController {

}
```



#### ⑤添加配置类

创建一个config文件夹，在文件夹下创建配置类，然后扫描mapper下的类和开启分页查询

```java
@Configuration
@MapperScan("com.xiaozhi.yygh.hosp.mapper")
public class HospConfig {
	/**
     * 分页插件
     * @return
     */
    @Bean
    public PaginationInterceptor paginationInterceptor() {
        return new PaginationInterceptor();
    }
}
```

启动没问题，那么环境搭建成功！！！



### 4	controller层设计

在实体类上开启逻辑删除功能

![image-20210505152501314](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210505152501314.png)

**说明**：因为我们的返回结果需要统一，所以统一将结果封装到Result类中返回

将资料\03-项目工具类\工具类\result中的文件放入到common模块com/xiaozhi/yygh/common/result包下

![image-20210505155824180](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210505155824180.png)

```java
@Api(tags = "医院设置管理")
@RestController
@RequestMapping("/admin/hosp/hospitalSet")
public class HospitalSetController {
    // 注入service
    @Autowired
    private HospitalSetService hospitalSetService;

    // 查询医院设置表所有信息
    @ApiOperation(value = "获取所有医院设置")
    @GetMapping("findAll")
    public Result findAllHospitalSet() {
        // 调用service方法
        List<HospitalSet> list = hospitalSetService.list();
        return Result.ok(list);
    }

    // 逻辑删除医院设置
    @DeleteMapping("{id}")
    @ApiOperation(value = "逻辑删除医院设置")
    public Result removeHospSet(@PathVariable("id") Integer id) {
        System.out.println(id);
        boolean flag = hospitalSetService.removeById(id);
        // 判断，成功返回成功信息，失败返回失败信息
        if (flag) {
            return Result.ok();
        } else {
            return Result.fail();
        }
    }
    
}
```

```java
// 带条件的分页查询
@ApiOperation(value = "带条件的分页查询")
@PoMapping("findPageHospSet/{current}/{limit}")
public Result findPageHospSet(@PathVariable Integer current,
                              @PathVariable Integer limit,
                              @RequestBody(required = false) HospitalSetQueryVo hospitalSetQueryVo) {
    // 创建page对象，传递当前页，每页记录数
    Page<HospitalSet> page = new Page<>();
    page.setCurrent(current);
    page.setSize(limit);
    // 构建条件
    QueryWrapper<HospitalSet> wrapper = new QueryWrapper<>();
    if (hospitalSetQueryVo.getHosname() != null) {
        // 根据医院名字查询
        wrapper.like("hosname",hospitalSetQueryVo.getHosname());
    }
    if (hospitalSetQueryVo.getHoscode() != null) {
        // 根据医院编号查询
        wrapper.eq("hoscode",hospitalSetQueryVo.getHoscode());
    }
    // 调用方法实现分页查询
    Page<HospitalSet> hospitalSetPage = hospitalSetService.page(page, wrapper);
    return Result.ok(hospitalSetPage);
}
```

**说明**：①vo包下的类是用来封装条值的

​		   ②@RequestBody用来接受请求体的内容，比如json格式的文件，==这里我们只能使用POST请求，因为Get请求中没有请求体==



### 5	集成swagger2

 @Api：修饰整个类，描述Controller的作用

  @ApiOperation：描述一个类的一个方法，或者说一个接口

  @ApiParam：单个参数描述

  @ApiModel：用对象来接收参数

  @ApiModelProperty：用对象接收参数时，描述对象的一个字段

  @ApiImplicitParam：一个请求参数

@ApiImplicitParams：多个请求参数



#### ①引入依赖

在common模块pom.xml引入依赖

```xml
<!--swagger-->
<dependency>
<groupId>io.springfox</groupId>
<artifactId>springfox-swagger2</artifactId>
</dependency>
<dependency>
<groupId>io.springfox</groupId>
<artifactId>springfox-swagger-ui</artifactId>
</dependency>
```

说明：因为我们在yygh-parnet中的pom.xml添加了版本控制，所以这里不需要添加版本



#### ②添加swagger2配置类

在service-util模块添加配置类

com.xiaozhi.yygh.common.config.Swagger2Config类

```java
/**
 * Swagger2配置信息
 */
@Configuration
@EnableSwagger2
public class Swagger2Config {
    @Bean
    public Docket webApiConfig(){
        return new Docket(DocumentationType.SWAGGER_2)
                .groupName("webApi")
                .apiInfo(webApiInfo())
                .select()
                //只显示api路径下的页面
                .paths(Predicates.and(PathSelectors.regex("/api/.*")))
                .build();
    }

    @Bean
    public Docket adminApiConfig(){
        return new Docket(DocumentationType.SWAGGER_2)
                .groupName("adminApi")
                .apiInfo(adminApiInfo())
                .select()
                //只显示admin路径下的页面
                .paths(Predicates.and(PathSelectors.regex("/admin/.*")))
                .build();
    }

    private ApiInfo webApiInfo(){
        return new ApiInfoBuilder()
                .title("网站-API文档")
                .description("本文档描述了网站微服务接口定义")
                .version("1.0")
                .contact(new Contact("xiaozhi", "http://xiaozhi.com", "493211102@qq.com"))
                .build();
    }

    private ApiInfo adminApiInfo(){
        return new ApiInfoBuilder()
                .title("后台管理系统-API文档")
                .description("本文档描述了后台管理系统微服务接口定义")
                .version("1.0")
                .contact(new Contact("xiaozhi", "http://xiaozhi.com", "49321112@qq.com"))
                .build();
    }
}
```

注意：因为我们的swagger所在的模块是service-util下的，不在我们的service-hosp模块下，所以它识别不到配置类，这时候我们需要手动扫描，在主启动类上添加扫描，因为都是com.xiaozhi开头的，所以我们扫描的位置就在com.xiaozhi包下的

```java
@SpringBootApplication
@ComponentScan(basePackages = "com.xiaozhi")
public class ServiceHospApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceHospApplication.class,args);
    }
}
```



#### ③测试

添加对应的注解实现不同的功能

![image-20210505170636577](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210505170636577.png)

然后网址输入http://localhost:8201/swagger-ui.html就可以看到我们刚才设置好内容了

![image-20210505164936506](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210505164936506.png)

![image-20210505165351511](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210505165351511.png)

![image-20210505165038125](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210505165038125.png)





# 医院设置前端搭建

## vue-element-admin

### 1	简介

vue-element-admin是基于element-ui 的一套后台管理系统集成方案。

GitHub地址：https://github.com/PanJiaChen/vue-element-admin

项目在线预览：[https://panjiachen.gitee.io/vue-element-admin](https://panjiachen.gitee.io/vue-element-admin/#/login?redirect=/dashboard)



### 2	安装

```sh
# 解压压缩包
# 进入目录
cd vue-element-admin-master
# 安装依赖
npm install
# 启动。执行后，浏览器自动弹出并访问http://localhost:9527/
npm run dev
```

如果上面的install报错

![image-20210506225147486](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210506225147486.png)

则先执行下面的命令，再install

```sh
npm i -g node-sass --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/
```





## vue-admin-template

### 1	简介

vueAdmin-template是基于vue-element-admin的一套后台管理系统基础模板（最少精简版），可作为模板进行二次开发。

GitHub地址：https://github.com/PanJiaChen/vue-admin-template

建议：你可以在 vue-admin-template 的基础上进行二次开发，把 vue-element-admin当做工具箱，想要什么功能或者组件就去 vue-element-admin 那里复制过来。



### 2	安装

```sh
# 解压压缩包
# 进入目录
cd vue-admin-template-master
# 安装依赖
npm install
# 启动。执行后，浏览器自动弹出并访问http://localhost:9528/
npm run dev
```



## 前端框架了解

### 1	目录结构

vue-element-admin-master（拥有完整的功能的插件）

![image-20210506230955863](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210506230955863.png)



### 2	关键文件

vue-admin-template-master（源码相对简单，我们的后台管理系统基于这个版本）

#### ①package.js

npm项目的核心配置文件，包含项目信息，项目依赖，项目启动相关脚本

启动项目的命令： npm run dev

dev脚本：webpack-dev-server --inline --progress --config build/webpack.dev.conf.js

webpack-dev-server：一个小型的基于Node.js的http服务器，可以运行前端项目

--inline：一种启动模式

--progress：显示启动进度

--config build/webpack.dev.conf.js：指定webpack配置文件所在位置

![image-20210506231222969](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210506231222969.png)



#### ②build/webpack.dev.conf.js

webpack配置文件，包含项目在开发环境打包和运行的相关配置

webpack.dev.conf.js 中引用了 webpack.base.conf.js

webpack.base.conf.js 中定义了项目打包的入口文件

![image-20210506231520744](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210506231520744.png)

![image-20210506231745056](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210506231745056.png)

在HtmlWebpackPlugin配置html模板，生成的js就会自动插入到模板中，如下面的配置。

因此生成的js文件会被自动插入到名为index.html的页面中

![image-20210506231847988](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210506231847988.png)·



#### ③index.html

项目默认的html页面

![image-20210506232810120](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210506232810120.png)

![image-20210506232907866](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210506232907866.png)



#### ④src/main.js

项目js入口文件，项目的所有前端功能都在这个文件中引入和定义，并初始化全局的Vue对象

![image-20210506233038435](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210506233038435.png)



#### ⑤config/dev.env.js

定义全局常量值

![image-20210506233303362](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210506233303362.png)

![image-20210506233350512](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210506233350512.png)

因此，在项目中的任意位置可以直接使用 process.env.BASE_API 常量表示后端接口的主机地址



#### ⑥src/utils/request.js

引入axios模块，定义全局的axios实例，并导出模块

![image-20210506233520206](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210506233520206.png)



#### ⑦src/api/login.js

引用request模块，调用远程api

![image-20210506233640485](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210506233640485.png)



### 3	临时登录接口

#### ①前端登录问题

默认情况下，前端项目已经实现了登录功能，后端连接到远程Mock平台的模拟数据接口进行登录，而Mock平台地址无效，导致前端的登录功能无法执行

![image-20210506234116950](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210506234116950.png)





## 管理平台前端搭建

### 1	项目信息修改

解压vue-admin-template-master.zip，项目重命名：yygh-admin

**修改package.json**

```json
{
  "name": "yygh-admin",
  "version": "3.8.0",
  "license": "MIT",
  "description": "尚医通管理平台系统",
  "author": "major <1596971466@qq.com>",
  ......
}
```

根据package.json来下载我们需要的依赖

```sh
npm install
```



### 2	项目目录结构

├── build // 构建脚本

├── config // 全局配置 

├── node_modules // 项目依赖模块

├── src //项目源代码

├── static // 静态资源

└── package.jspon // 项目信息和依赖配置

 

src 

├── api // 各种接口

├── assets // 图片等资源 

├── components // 各种公共组件，非公共组件在各自view下维护 

├── icons //svg icon 

├── router // 路由表 

├── store // 存储

├── styles // 各种样式 

├── utils // 公共工具，非公共工具，在各自view下维护 

├── views // 各种layout

├── App.vue //***项目顶层组件*** 

├── main.js //***项目入口文件***

└── permission.js //认证入口



### 3	登录页修改

将登陆相关请求接口改为静态数据，不请求接口

**修改文件：\src\store\modules\user.js**，修改三个部分，登录，获取用户信息，登出

```js
 actions: {
    // 登录
    Login({ commit }, userInfo) {
          const data = {"token":"admin"}
          setToken(data.token)
          commit('SET_TOKEN', data.token)
      // const username = userInfo.username.trim()
      // return new Promise((resolve, reject) => {
      //   login(username, userInfo.password).then(response => {
      //     const data = response.data
      //     setToken(data.token)
      //     commit('SET_TOKEN', data.token)
      //     resolve()
      //   }).catch(error => {
      //     reject(error)
      //   })
      // })
    },

    // 获取用户信息
    GetInfo({ commit, state }) {
      const data = {'roles':'admin','name':'admin','avater':'https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif'}
      if (data.roles && data.roles.length > 0) { // 验证返回的roles是否是一个非空数组
        commit('SET_ROLES', data.roles)
      } else {
        reject('getInfo: roles must be a non-null array !')
      }
      commit('SET_NAME', data.name)
      commit('SET_AVATAR', data.avatar)
      // return new Promise((resolve, reject) => {
      //   getInfo(state.token).then(response => {
      //     const data = response.data
      //     if (data.roles && data.roles.length > 0) { // 验证返回的roles是否是一个非空数组
      //       commit('SET_ROLES', data.roles)
      //     } else {
      //       reject('getInfo: roles must be a non-null array !')
      //     }
      //     commit('SET_NAME', data.name)
      //     commit('SET_AVATAR', data.avatar)
      //     resolve(response)
      //   }).catch(error => {
      //     reject(error)
      //   })
      // })
    },

    // 登出
    LogOut({ commit, state }) {
      commit('SET_TOKEN', '')
      commit('SET_ROLES', [])
      removeToken()
      // return new Promise((resolve, reject) => {
      //   logout(state.token).then(() => {
      //     commit('SET_TOKEN', '')
      //     commit('SET_ROLES', [])
      //     removeToken()
      //     resolve()
      //   }).catch(error => {
      //     reject(error)
      //   })
      // })
    },

    // 前端 登出
    FedLogOut({ commit }) {
      return new Promise(resolve => {
        commit('SET_TOKEN', '')
        removeToken()
        resolve()
      })
    }
  }
}
```

**说明**：token是我们手动配置的，如果过期后续自行生成，后续会有TokenHelper类生成token，在此不用关注



**修改\src\util\request.js**

```js
config.headers['token'] = getToken()
```

使用npm install dev运行项目



## 医院设置管理模块搭建

### 1	项目开发流程

![image-20210507130033026](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210507130033026.png)

![image-20210507161703273](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210507161703273.png)

**说明**：首先设置路由跳转，然后设置我们的axios向后端发送请求，接着将请求到的数据交给我们views进行渲染，然后展示给客户



### 2	项目开发

#### ①定义路由模块

src/router/index.js

配置医院设置管理相关路由

修改模板example处写好的模板，根据官方的模板可以自己添加对应的路由

```js
{
    path: '/hospSet',
    component: Layout,
    redirect: '/hospSet/list',
    name: '医院设置管理',
    meta: { title: '医院设置管理', icon: 'example' },
    children: [
      {
        path: 'list',
        name: '医院设置列表',
        component: () => import('@/views/table/index'),
        meta: { title: '医院设置列表', icon: 'table' }
      },
      {
        path: 'add',
        name: '医院设置添加',
        component: () => import('@/views/tree/index'),
        meta: { title: '医院设置添加', icon: 'tree' }
      }
    ]
  }
```



#### ②创建api

模仿官方的例子创建

src/api/hospSet.js

```js
import request from '@/utils/request'   // 引入封装好的axios

export function getList(params) {

}
export default {
    getHospSetList(current,limit,searchObj) {
        return request({
            // url是接口的请求地址
            url: `/admin/hosp/hospitalSet/findPageHospitalSet/${current}/${limit}`,
            // 请求的方式
            method: 'post',
            data: searchObj     // 使用json形式进行传递
        })
    }
}
```



#### ③创建view

在views文件夹下创建一个hospSet文件夹，在hospSet文件夹下创建两个文件

list.vue

```js
<template>
    <div class="app-container">
        医院设置列表
    </div>
</template>
```

add.vue

```js
<template>
    <div class="app-container">
        医院设置添加
    </div>
</template>
```



#### ④测试

![image-20210507160040240](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210507160040240.png)

在浏览器中就可以看到我们通过路由跳转到了对应的页面



#### ⑤修改后端接口的主机和端口号

![image-20210507162211492](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210507162211492.png)

**注意**：当前不能写https，因为我们还没进行加密传输



#### ⑥修改list.vue中的代码

```js
<template>
    <div class="app-container">
        医院设置列表
    </div>
</template>

<script>
// 引入接口定义的js文件
import hospSet from '@/api/hospSet'
export default {
    data() {
        return {
            current: 1,     // 当前页
            limit: 3,       // 每页显示记录数
            searchObj: {},  // 条件封装的对象
            list: []        // 每页数据集合
        }
    },
    created() { // 页面渲染之前执行
        // 一般调用methods定义的方法，得到数据
        this.getList()
    },
    methods: {  // 定义方法，进行接口调用
        // 医院设置列表
        getList() {
            hospSet.getHospSetList(this.current,this.limit,this.searchObj)
                .then(response => {
                    console.log(response)
                })     // 请求成功，response是接口返回的数据
                            // 为了有实际意义才写response
                .catch(error => {
                    console.log(error);
                })    // 请求失败
        }
    }
}
</script>
```



#### ⑦访问后端测试

此时报了个错

![image-20210507165325384](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210507165325384.png)



### 3	跨域问题

三个地方，任何一个不相同都会产生跨域问题

协议访问：	http		https

访问地址：	192.168.1.1		172.11.1.1

端口号：		9528	8201



**解决跨域问题**

简单的解决方案：在我们的controller类上添加@CrossOrigin注解可以解决跨域问题

![image-20210507165724102](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210507165724102.png)



### 4	接着开发

#### ①存在问题

前端和后端的成功码不一致

![image-20210507165914243](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210507165914243.png)

**解决**：将前端的修改成200或者将后端的修改成2000



#### ②进行测试

![image-20210507170113927](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210507170113927.png)

可以看到，成功的访问到了后端传来的数据！



#### ③取出我们需要的数据

![image-20210507170554464](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210507170554464.png)



#### ④将数据显示在页面上

```html
<template>
<div class="app-container">

<!-- banner列表 -->
<el-table
:data="list"
stripe
      style="width: 100%">

<el-table-column type="index" width="50"/>
<el-table-column prop="hosname" label="医院名称"/>
<el-table-column prop="hoscode" label="医院编号"/>
<el-table-column prop="apiUrl" label="api基础路径"width="200"/>
<el-table-column prop="contactsName" label="联系人姓名"/>
<el-table-column prop="contactsPhone" label="联系人手机"/>
<el-table-column label="状态" width="80">
<template slot-scope="scope">
          {{ scope.row.status === 1 ? '可用' : '不可用' }}
</template>
</el-table-column>
</el-table>
</div>
</template>
```

参考官方文档！！！



#### ⑤分页查询

使用element官方的分页

```html
   </el-table>
        <!-- 分页 -->
        <el-pagination
            :current-page="current"
            :page-size="limit"
            :total="total"
            style="padding: 30px 0; text-align: center;"
            layout="total,prev, pager, next, jumper"
            @current-change="getList"
            >
        </el-pagination>
```

里面的参数都是可以参考官方文档进行解读 

![image-20210507184631792](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210507184631792.png)



### 5	输入查询功能实现

**增加输入框组件**

views/hospSet/list.vue

```html
<div class="app-container">
    // 搜索功能
    <el-form :inline="true" class="demo-form-inline">
      <el-form-item>
        <el-input v-model="searchObj.hosname" placeholder="医院名称" />
      </el-form-item>
      <el-form-item>
        <el-input v-model="searchObj.hoscode" placeholder="医院编号" />
      </el-form-item>
      <el-button type="primary" icon="el-icon-search" @click="getList()">查询</el-button>
    </el-form>
```

点击查询就会调用getList()函数



### 6	删除功能实现

#### ①定义api模块

在src/api/hosp/hospSet.js添加方法

```js
// 删除医院设置
 removeById(id) {
    return request({
        url: `/admin/hosp/hospitalSet/${id}`,
        method: 'delete'
    })
}
```



#### ②定义页面组件模板

在table组件中添加删除列

```html
<el-table-column label="操作" width="280" align="center">
    <template slot-scope="scope">
        <el-button
                   type="danger"
                   size="mini"
                   icon="el-icon-delete"
                   @click="removeDataById(scope.row.id)"
        ></el-button>
    </template>
</el-table-column>
```

**说明**：

1、slot-scope="scope"

这是作用域插槽中定义一个对象(这里对象被定义为scope)来存储插槽上绑定的数据的用法

2、scope.row

在这里使用ElementUI表格模板渲染数据时,"当前行数据的获取也会用到插槽,scope相当于一行的数据， scope.row相当于当前行的数据对象,也就是我们的表格遍历数据的对象“

**注意**：插槽必须结合template模板结合使用



#### ③定义页面组件脚本

```js
// 删除医院设置的方法
    removeById(id) {
      this.$confirm('此操作将删除医院设置信息，是否继续？','提示',{
        confirmButtonText: '确定',
        canceButtonText: '取消',
      }).then(() => {   // 确定就执行then方法
        hospSet.removeById(id)
        .then(reponse => {
          // 删除成功提示
          this.$message({
            type: 'success',
            message: '删除成功！'
          })
        })
        // 删除之后刷新页面
        this.getList(1)   // 回到首页
      })
    },
```





### 7	批量删除功能实现

#### ①定义api模块

```js
// 批量删除医院设置
    batchRemoveHospSet(idList) {
        return request({
            url: `/admin/hosp/hospitalSet/batchRemove`,
            method: 'delete', 
            data: idList
        })
    },
```



#### ②定义页面组件模板

在table组件上添加一个按钮

```html
<div>
	<el-button type="danger" size="mini" @click="batchRemoveHospSet()">批量删除</el-button>
</div>
```

在table组件第一列中添加一个选择框

```html
<el-table-column type="selection" width="55"/>
```

在table元素中绑定选择改变事件

```js
<el-table :data="list" stripe style="width: 100%" @selection-change="handleSelectionChange">
```

![image-20210508202203757](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210508202203757.png)

**说明**：当我们选择当前选项是就会触发绑定的事件，它会帮我们将选择的这一列对象封装好，我们用一个参数接收即可



#### ③定义页面组件脚本

定义事件出发后的函数

```js
handleSelectionChange(selection) {
	this.multipleSelection = selection
}, 
```

调用接口进行删除

```js
batchRemoveHospSet() {
    this.$confirm("此操作将删除医院设置信息，是否继续？", "提示", {
        confirmButtonText: "确定",
        cancelButtonText: "取消",
    }).then(() => {   // 确定就执行then方法
        var idList = []
        for(let i = 0; i < this.multipleSelection.length; i++) {
            var obj = this.multipleSelection[i]   // 拿出封装好的数据
            var id = obj.id
            idList.push(id)   // 将id放入到数组中
        }
        // 调用接口
        hospSet.batchRemoveHospSet(idList).then((reponse) => {
            // 删除成功提示
            this.$message({
                type: "success",
                message: "删除成功！",
            });
        });
        // 删除之后刷新页面
        this.getList(1); // 回到首页
    })
},
```



### 8	锁定功能实现

#### ①定义api模块

```js
    // 锁定与取消锁定
    lockHospSet(id,status) {
        return request({
            url: `/admin/hosp/hospitalSet/lockHospitalSet/${id}/${status}`,
            method: 'put',
        })
    },
```



#### ②定义页面组件模板

在操作列下面添加两个按钮

```html
 <el-button v-if="scope.row.status==1" type="success" size="mini" @click="lockHospSet(scope.row.id,0)">锁定</el-button>
          <el-button v-if="scope.row.status==0" type="danger" size="mini" @click="lockHospSet(scope.row.id,1)">取消锁定</el-button>
```



#### ③定义页面组件脚本

```js
// 锁定与取消锁定
    lockHospSet(id,status) {
      hospSet.lockHospSet(id,status)
        .then((reponse) => {
          //刷新
          this.getList(this.current)
        })
    },
```



### 9	添加医院设置

#### ①定义api模块

在 src/api/hosp/hospitalSet.js添加方法

```js
    // 添加医院设置
    addHospSet() {
        return request ({
            url: `/admin/hosp/hospitalSet/saveHospitalSet`,
            method: 'post',
            data: hospitalSet
        })
    },
```



#### ②定义页面组件模板

src/views/hosp/hospitalSet/form.vue

```html
<template>
  <div class="app-container">
    医院设置添加
    <el-form label-width="120px">
      <el-form-item label="医院名称">
        <el-input v-model="hospSet.hosname" />
      </el-form-item>
      <el-form-item label="医院编号">
        <el-input v-model="hospSet.hoscode" />
      </el-form-item>
      <el-form-item label="api基础路径">
        <el-input v-model="hospSet.apiUrl" />
      </el-form-item>
      <el-form-item label="联系人姓名">
        <el-input v-model="hospSet.contactsName" />
      </el-form-item>
      <el-form-item label="联系人手机">
        <el-input v-model="hospSet.contactsPhone" />
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click="save">保存</el-button>
      </el-form-item>
    </el-form>
  </div>
</template>
```



#### ③定义页面组件脚本

```js
<script>
import hospSet from "@/api/hospSet";
export default {
  data() {
    return {
      // 接收表单
      hospSet: {},
    };
  },
  created() {
      
  },
  methods: {
    save() {
      hospSet.addHospSet(this.hospSet).then((response) => {
        //提示
        this.$message({
          type: "success",
          message: "添加成功!",
        })
        // 路由跳转到list页面
        this.$router.push({path:'/hospSet/list'})
      })
    },
  },
};
</script>
```



### 10	修改设置功能

#### ①定义一个隐藏路由

src/router/index.js下添加一个子路由

```js
	{
        path: 'edit/:id',   // 这个冒号就相当于?，是用来接参数的
        name: '医院设置修改',
        component: () => import('@/views/hospSet/add'), // 和添加共用一个组件
        meta: {
          title: '医院设置修改',
          icon: 'tree'
        },
        hidden: true,   // 隐藏，这个路由不会在页面中显示
      },
```



#### ②设置按钮跳转

在list.vue文件中添加按钮

```html
 <router-link :to="'/hospSet/edit/' + scope.row.id">
 	<el-button type="primary" size="mini" icon="el-icon-edit">修改</el-button>
 </router-link>
```



#### ③定义api模块

在 src/api/hosp/hospitalSet.js添加方法获取显示的数据

```js
    // 根据id查询
    getHospSet(id) {
        return request ({
            url: `/admin/hosp/hospitalSet/getHospitalSet/${id}`,
            method: 'get',
        })
    },
```



#### ③定义页面组件脚本

src/views/hosp/hospitalSet/list.vue，methods中定义回显方法

```js
getHospSet(id) {
    hospSet.getHospSet(id)
        .then((response) => {
        // 将数据交给data中的hospSet属性
        this.hospSet = response.data
    })
},
```

页面渲染成功后获取数据



#### ⑤判断是添加还是修改

因为添加和修改是共用一个组件，所以我们需要区分一下是进行添加操作还是修改操作，我们已经在路由中定义如下内容：path: 'edit/:id'，因此可以使用 this.$route.params.id 获取路由中的id来进行判断，有id那就是修改，没有id就是添加

```js
  created() {
    // 在渲染之前执行
    // 获取路由id值，调用接口得到医院设置信息
    if (this.$route.params && this.$route.params.id) {
      // 有参数和有id值就进行修改操作
      const id = this.$route.params.id;
      this.id = id;
      this.getHospSet(id); // 调用接口得到数据
    }
  },
```



#### ⑥定义新增api

```js
 // 医院设置修改
    updateHospSet(hospSet) {
        return request ({
            url: `/admin/hosp/hospitalSet/updateHospitalSet`,
            method: 'post',
            data: hospSet
        })
    }
```



#### ⑦定义页面脚本

增加修改方法

```js
    // 修改
    update() {
      hospSet.updateHospSet(this.hospSet).then((response) => {
        //提示
        this.$message({
          type: "success",
          message: "修改成功!",
        })
        this.$router.push({ path: "/hospSet/list" })
      })
    },
```



#### ⑧修改保存按钮

我们使用同一个组件，保存跳转的函数只有一个，需要去分是新增还是修改

![image-20210508224409265](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210508224409265.png)



#### ⑨完善saveOrUpdate方法

```js
// 完善saveOrUpdate函数
saveOrUpdate() {
    if (this.id == -1) ) {
        // 没有id就是做添加
        this.save();
    } else {
        this.update();
    }
},
```



### 11	组件重用问题

**问题：**vue-router导航切换 时，如果两个路由都渲染同个组件，组件的生命周期方法（created或者mounted）只能调用一次, 组件会被重用，显示上一个路由渲染出来的，也就是我在修改页面点击添加，那么还是会使用修改的组件

**解决方案**：可以简单的在 router-view上加上一个唯一的key，来保证路由切换时都会重新触发生命周期方法，确保组件被重新初始化。



**修改 src/views/layout/components/AppMain.vue 文件如下**

```js
computed: {
    key() {
      return this.$route.name !== undefined ? this.$route.name + +new Date() : this.$route + +new Date()
    }
  }
```

```js
    <transition name="fade-transform" mode="out-in">
      <!-- or name="fade" -->
      <router-view :key="key"></router-view>
      <router-view/>
```

![image-20210508225809659](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210508225809659.png)







# 数据字典模块搭建

## 1	介绍

何为数据字典？数据字典就是管理系统常用的分类数据或者一些固定数据，例如：省市区三级联动数据、民族数据、行业数据、学历数据等，由于该系统大量使用这种数据，所以我们要做一个数据管理方便管理系统数据，一般系统基本都会做数据管理。



### ①页面效果

![image-20210509204826566](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210509204826566.png)



### ②数据库设计

![image-20210509204950156](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210509204950156.png)



### ③数据库设计分析

![image-20210509205033908](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210509205033908.png)

**parent_id**：上级id，通过id与parent_id构建上下级关系，例如：我们要获取所有行业数据，那么只需要查询parent_id=20000的数据

**name**：名称，例如：填写用户信息，我们要select标签选择民族，“汉族”就是数据字典的名称

**value**：值，例如：填写用户信息，我们要select标签选择民族，“1”（汉族的标识）就是数据字典的值

**dict_code**：编码，编码是我们自定义的，全局唯一，例如：我们要获取行业数据，我们可以通过parent_id获取，但是parent_id是不确定的，所以我们可以根据编码来获取行业数据

**说明**：系统中会使用省市区三级联动数据，该数据我们来自“国家统计局”官方数据，地址：http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2019/index.html



### ④根据页面效果分析数据接口

数据字典是树形展示，由于数据众多，我们使用“树形数据与懒加载”的方式展现数据列表，其他就是对数据的新增、修改与删除操作，因此需要提供的接口如下：

1，根据上级id获取下级数据（构造树形数据），参考文档：https://element.eleme.cn/#/zh-CN/component/table，页面搜索：树形数据与懒加载

2，导入excel文件接口

3，导出excel文件接口



## 2	数据字典环境搭建

### ①搭建service-cmn模块

搭建过程参考service-hosp模块



### ② 修改配置

1、修改pom.xml

```xml
<?xml version="1.0"encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion>
<parent>
<groupId>com.atguigu.yygh</groupId>
<artifactId>service</artifactId>
<version>1.0</version>
</parent>

<version>1.0</version>
<artifactId>service-cmn</artifactId>
<packaging>jar</packaging>
<name>service-cmn</name>
<description>service-cmn</description>

<dependencies>
</dependencies>

<build>
<finalName>service-cmn</finalName>
<plugins>
<plugin>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-maven-plugin</artifactId>
</plugin>
</plugins>
</build>

</project>
```

2、添加配置文件application.properties

```properties
# 服务端口
server.port=8202
# 服务名
spring.application.name=service-cmn

# 环境设置：dev、test、prod
spring.profiles.active=dev

# mysql数据库连接
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/yygh_cmn?characterEncoding=utf-8&useSSL=false
spring.datasource.username=root
spring.datasource.password=root

#返回json的全局时间格式
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8

#配置mapper xml文件的路径
#mybatis-plus.mapper-locations=classpath:com/xiaozhi/yygh/mapper/xml/*.xml
mybatis-plus.mapper-locations=classpath:com/xiaozhi/yygh/cmn/mapper/xml/*.xml
```



### ③启动类

```java
@SpringBootApplication
@ComponentScan(basePackages = "com.xiaozhi")
public class ServiceCmnApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceCmnApplication.class,args);
    }
}
```



## 3	数据字典列表

根据element组件要求，返回列表数据必须包含hasChildren字典，如图：

https://element.eleme.cn/#/zh-CN/component/table

![image-20210510152501638](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210510152501638.png)

**说明**：它会通过这个字段判断是否含有子节点的



### ①数据字典列表接口

#### 1、 添加数据字典实体类

```java
@Data
@ApiModel(description = "数据字典")
@TableName("dict")
public class Dict {

    private static final long serialVersionUID = 1L;

    @ApiModelProperty(value = "id")
    private Long id;

    @ApiModelProperty(value = "创建时间")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @TableField("create_time")
    private Date createTime;

    @ApiModelProperty(value = "更新时间")
    @TableField("update_time")
    private Date updateTime;

    @ApiModelProperty(value = "逻辑删除(1:已删除，0:未删除)")
    @TableLogic
    @TableField("is_deleted")
    private Integer isDeleted;

    @ApiModelProperty(value = "其他参数")
    @TableField(exist = false)
    private Map<String,Object> param = new HashMap<>();

    @ApiModelProperty(value = "上级id")
    @TableField("parent_id")
    private Long parentId;

    @ApiModelProperty(value = "名称")
    @TableField("name")
    private String name;

    @ApiModelProperty(value = "值")
    @TableField("value")
    private String value;

    @ApiModelProperty(value = "编码")
    @TableField("dict_code")
    private String dictCode;

    @ApiModelProperty(value = "是否包含子节点")
    // 标识数据库不存在该字段
    @TableField(exist = false)
    private boolean hasChildren;
}
```

**说明**：hasChildren为树形组件所需字典，标识为数据库表不存在该字段



#### 2、添加数据字典mapper

添加com.atguigu.yygh.cmn.mapper.DictMapper

```java
public interface DictMapper extends BaseMapper<Dict> {

}
```



#### 3、添加数据字典service

①添加com.atguigu.yygh.cmn.service.DictService

```java
public interface DictService extends IService<Dict> {
    //根据数据id查询子数据列表
    List<Dict> findChlidData(Long id);
}
```



②添加com.atguigu.yygh.cmn.service.impl.DictServiceImpl接口实现

```java
@Service
public class DictServiceImpl extends ServiceImpl<DictMapper,Dict> implements DictService {

    @Override
    public List<Dict> findChildData(Long id) {
        // 创建一个QueryWrapper对象
        QueryWrapper<Dict> wrapper = new QueryWrapper<>();
        wrapper.eq("parent_id",id);
        List<Dict> dictList = baseMapper.selectList(wrapper);
        // 判断是否子节点
        for (Dict dict : dictList) {
            Long dictId = dict.getId();
            boolean isChild = this.isChildren(dictId);
            dict.setHasChildren(isChild);
        }
        return dictList;
    }
    // 判断id下面是否含有子节点
    private boolean isChildren(Long dictId) {
        // 创建一个QueryWrapper对象
        QueryWrapper<Dict> wrapper = new QueryWrapper<>();
        wrapper.eq("parent_id",dictId);
        // 查询这个id的有多少条记录
        Integer count = baseMapper.selectCount(wrapper);
        // 0>0为false
        return count > 0;
    }
}
```



#### 4、添加数据字典controller

```java
@Api(tags = "数据字典")
@RestController
@RequestMapping("/admin/cmn/Dict")
@CrossOrigin    // 允许跨域访问
public class CmnController {
    // 注入service
    @Autowired
    private DictService dictService;

    //根据数据id查询子数据列表
    @ApiOperation("根据数据id查询子数据列表")
    @GetMapping("findChildData/{id}")
    public Result findChildData(@PathVariable Long id) {
        List<Dict> dictList = dictService.findChildData(id);
        return Result.ok(dictList);
    }
}
```



### ②数据字典列表前端

#### 1、添加路由

```js
{
    path: '/cmn',
    component: Layout,
    redirect: '/cmn/list',
    name: '数据管理',
    alwaysShow: true,
    meta: { title: '数据管理', icon: 'example' },
    children: [
      {
        path: 'list',
        name: '数据字典',
        component: () => import('@/views/dict/list'),
        meta: { title: '数据字典', icon: 'table' }
      }
    ]
  },
```

说明：列表与查看都添加了



#### 2、修改接口的端口号

这里测试进行修改即可，后面我们会使用nginx来进行转发

config/dev.env.js

![image-20210510171414639](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210510171414639.png)



#### 3、定义api

```js
export default {
  dictList(id) {//数据字典列表
    return request ({
      url: `/admin/cmn/dict/findChildData/${id}`,
      method: 'get'
    })
  }
}
```



#### 4、定义js脚本

```js
<script>
import dict from '@/api/dict'
export default {
    data() {
        return {
            // 数据字典列表数组
            list: []
        }
    },
    created() {
        // 调用方法得到数据
        this.getDictList(1)
    },
    methods: {
        getDictList(id) {
            dict.getDictList(id).then(response => {
                // 将得到的数据赋给数组
                this.list = response.data
            })
        }
    }
}
</script>
```



#### 5、表格渲染

```html
<template>
    <div class="app-container">
        <el-table
        :data="list"
        style="width: 100%"
        row-key="id"
        border
        lazy
        :load="getChildrens"
        :tree-props="{children: 'children', hasChildren: 'hasChildren'}">
            <el-table-column label="名称" width="230" align="left">
            <template slot-scope="scope">
            <span>{{ scope.row.name }}</span>
            </template>
            </el-table-column>

            <el-table-column label="编码" width="220">
            <template slot-scope="{row}">
                    {{ row.dictCode }}
            </template>
            </el-table-column>
            <el-table-column label="值" width="230" align="left">
            <template slot-scope="scope">
            <span>{{ scope.row.value }}</span>
            </template>
            </el-table-column>
            <el-table-column label="创建时间" align="center">
            <template slot-scope="scope">
            <span>{{ scope.row.createTime }}</span>
            </template>
            </el-table-column>
        </el-table>
    </div>
</template>
```

我们还需要给它添加一个方法

![image-20210510172846207](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210510172846207.png)

这是一个懒加载的方法，当我们点击展开按钮的时候它才会进行加载，我们将它和getChildrens方法进行绑定

![image-20210510173024157](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210510173024157.png)

```js
getChildrens(tree, treeNode, resolve) {
            dict.dictList(tree.id).then(response => {
                resolve(response.data)
            })
        },
```



**发现问题**：我们在浏览器中访问，发现没有子节点的信息，这是因为我们项目中的element-ui版本过低导致的

**解决问题**：在package.json文件中修改element-ui版本为2.12.0，然后删除项目中原有的element-ui文件，npm install 重新下载

我们就可以看到我们先要的效果了

![image-20210510185849724](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210510185849724.png)





## 4	集成EasyExcel

### 添加依赖

```xml
    <dependencies>
        <!-- https://mvnrepository.com/artifact/com.alibaba/easyexcel -->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>easyexcel</artifactId>
        </dependency>
    </dependencies>
```

**说明**：我们在yygh-parent中的pom.xml添加了所有的依赖管理，所以这里不用写版本



## 5	字典导出功能

### 接口开发

#### ①导出接口封装

```java
@Data
public class DictEeVo {

	@ExcelProperty(value = "id" ,index = 0)
	private Long id;

	@ExcelProperty(value = "上级id" ,index = 1)
	private Long parentId;

	@ExcelProperty(value = "名称" ,index = 2)
	private String name;

	@ExcelProperty(value = "值" ,index = 3)
	private String value;

	@ExcelProperty(value = "编码" ,index = 4)
	private String dictCode;

}
```



#### ②添加service方法

```java
// 导出数据字典接口
void exportDictData(HttpServletResponse response);
```



#### ③实现类中重写方法

```java
// 字典导出接口
@Override
public void exportDictData(HttpServletResponse response) {
    // 文件的类型
    response.setContentType("application/vnd.ms-excel");
    // 设置浏览器的编码
    response.setCharacterEncoding("utf-8");
    // 文件名
    String fileName = "dict";
    // 告诉浏览器以附件的形式下载
    response.setHeader("Content-disposition","attachment:filename=" + fileName + ".xlsx");
    // 查询数据库
    List<Dict> dictList = baseMapper.selectList(null);

    // Dict转换成DDictEeVo
    List<DictEeVo> dictEeVoList = new ArrayList<>();
    for (Dict dict : dictList) {
        DictEeVo dictEeVo = new DictEeVo();
        // 这个方法就是get到对象的属性值，然后set到另一个对象属性
        // 相当于是 dictEeVo.setId(dict.getId());
        BeanUtils.copyProperties(dict,dictEeVo);
        dictEeVoList.add(dictEeVo);
    }
    // 调用方法进行write操作
    try {
        EasyExcel.write(response.getOutputStream(), DictEeVo.class).sheet("dict").doWrite(dictEeVoList);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```



#### ④添加controller方法

```java
// 导出数据字典接口
@GetMapping("exportData")
public Result exportDict(HttpServletResponse response) {
    dictService.exportDictData(response);
    return Result.ok();
}
```



#### ⑤测试

访问http://localhost:8201/admin/cmn/dict/exportData



### 前端展示

#### ①列表页面添加导出按钮

```java
<div class="el-toolbar">
    <div class="el-toolbar-body"style="justify-content: flex-start;">
    	<el-button type="text"@click="exportData"><i class="fa fa-plus"/> 导出</el-button>
    </div>
</div>
```



#### ②添加导出方法

```js
    // 导出按钮触发事件
    exportData() {
        // 发送下载请求
        window.location.href='http://localhost:8202/admin/cmn/dict/exportData'
    },
```





## 6	数据字典导入

### ①接口开发

#### 1、创建回调监听器

```java
public class DictListener extends AnalysisEventListener<DictEeVo> {
   private DictMapper dictMapper;
   // 通过构造器传递参数
   public DictListener(DictMapper dictMapper) {
       this.dictMapper = dictMapper;
   }

    // 一行一行读取
    @Override
    public void invoke(DictEeVo dictEeVo, AnalysisContext analysisContext) {
       // 调用方法添加数据库
        Dict dict = new Dict();
        BeanUtils.copyProperties(dictEeVo,dict);
        dictMapper.insert(dict);
    }

    @Override
    public void doAfterAllAnalysed(AnalysisContext analysisContext) {

    }
}
```



#### 2、实现servie方法

```java
@Override
public void importDictData(MultipartFile file) {
    try {
   		EasyExcel.read(file.getInputStream(),DictEeVo.class,newDictListener(baseMapper))
                .sheet().doRead();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```



#### 3、修改实体类

因为我们要进行一个转换，dictEeVo转dict，转成之后它会做一个auto的自增操作，会使我们的id变乱，所以我们不要让我们的实体类继承BaseEntity类，将其中的属性复制到我们的实体类中

```java
@Data
@ApiModel(description = "数据字典")
@TableName("dict")
public class Dict {

    private static final long serialVersionUID = 1L;

    @ApiModelProperty(value = "id")
    private Long id;

    @ApiModelProperty(value = "创建时间")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @TableField("create_time")
    private Date createTime;

    @ApiModelProperty(value = "更新时间")
    @TableField("update_time")
    private Date updateTime;

    @ApiModelProperty(value = "逻辑删除(1:已删除，0:未删除)")
    @TableLogic
    @TableField("is_deleted")
    private Integer isDeleted = 0;

    @ApiModelProperty(value = "其他参数")
    @TableField(exist = false)
    private Map<String,Object> param = new HashMap<>();

    @ApiModelProperty(value = "上级id")
    @TableField("parent_id")
    private Long parentId;

    @ApiModelProperty(value = "名称")
    @TableField("name")
    private String name;

    @ApiModelProperty(value = "值")
    @TableField("value")
    private String value;

    @ApiModelProperty(value = "编码")
    @TableField("dict_code")
    private String dictCode;

    @ApiModelProperty(value = "是否包含子节点")
    @TableField(exist = false)
    private boolean hasChildren;

}
```



#### 4、定义controller方法

```java
// 导入数据字典接口
    @ApiOperation("导入数据")
    @PostMapping("importData")
    public Result importDictData(MultipartFile file) {
        dictService.importDictData(file);
        return Result.ok();
    }
```



### ②前端展示

#### 1、添加导入按钮

在导出组件的隔壁添加导入按钮的组件

```html
<el-button type="text" @click="importData">
    <i class="fa fa-plus" /> 导入
</el-button>
```



#### 2、导入弹框组件

在后面添加上弹框组件

```html
<!-- 弹窗 -->
    <!-- dialogImportVisible为flase就不弹出来 -->
    <el-dialog title="导入" :visible.sync="dialogImportVisible" width="480px">
      <el-form label-position="right" label-width="170px">
        <el-form-item label="文件">

          <el-upload
            :multiple="false"
            :on-success="onUploadSuccess"
            :action="'http://localhost:8202/admin/cmn/dict/importData'"
            class="upload-demo"
          >
            <el-button size="small" type="primary">点击上传</el-button>
            <div slot="tip" class="el-upload__tip">只能上传xls文件，且不超过500kb</div>
          </el-upload>

        </el-form-item>
      </el-form>
      <div slot="footer" class="dialog-footer">
        <el-button @click="dialogImportVisible = false">取消</el-button>
      </div>
    </el-dialog>
```



#### 3、定义脚本

添加导入按钮触发事件函数

```js
// 导入数据
importData() {
    // 设置可以弹出
    this.dialogImportVisible = true 
},
```



上传成功调用的函数

```js
// 上传成功调用
onUploadSuccess() {
    this.$message.info('上传成功')
    // 关闭弹窗
    this.dialogImportVisible = false
    // 刷新页面
    this.getDictList(1);
},
```



# 使用nginx

## 1	修改配置文件

在这里我们暂时使用windows版的nginx来进行开发

修改nginx-1.12.0\conf中的nginx.conf配置文件，在最后面添加上下面一段配置

```conf
server {
		listen		9001;
		server_name	localhost;
		
		localhost ~ /hosp/ {
			proxy_pass http://localhost:8201;
		}
		localhost ~ /cmn/ {
			proxy_pass http://localhost:8202;
		}
		localhost ~ /eduvod/ {
			proxy_pass http://localhost:8203;
		}
		localhost ~ /cmsservice/ {
			proxy_pass http://localhost:8004;
		}localhost ~ /ucenterservice/ {
			proxy_pass http://localhost:8150;
		}
		localhost ~ /edumsm/ {
			proxy_pass http://localhost:8005;
		}
		localhost ~ /orderservice/ {
			proxy_pass http://localhost:8007;
		}
		localhost ~ /staservice/ {
			proxy_pass http://localhost:8008;
		}
		localhost ~ /admin/ {
			proxy_pass http://localhost:8009;
		}
	}
```

然后在nginx-1.12.0目录下cmd启动nginx

```sh
E:\Java\nginx-1.12.0>nginx.exe
```



## 2	修改前端地址

config/dev.env.js文件下修改一下端口号

```js
BASE_API: '"http://localhost:9001"',
```



## 3	测试

可以同时访问两个目录既成功



# Spring Cache + Redis 缓存数据

Spring Cache 是一个非常优秀的缓存组件。自Spring 3.1起，提供了类似于@Transactional注解事务的注解Cache支持，且提供了Cache抽象，方便切换各种底层Cache（如：redis）

使用Spring Cache的好处：

  1，提供基本的Cache抽象，方便切换各种底层Cache；

  2，通过注解Cache可以实现类似于事务一样，缓存逻辑透明的应用到我们的业务代码上，且只需要更少的代码就可以完成；

  3，提供事务回滚时也自动回滚缓存；

  4，支持比较复杂的缓存逻辑；



## 1	项目集成Spring Cache + Redis

### ①添加依赖

因为缓存也是公共使用，所有的service模块都有可能使用缓存，所以我们把依赖与部分配置加在service-util模块，这样其他service模块都可以使用了

```xml
<!-- redis -->
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

<!-- spring2.X集成redis所需common-pool2-->
<dependency>
<groupId>org.apache.commons</groupId>
<artifactId>commons-pool2</artifactId>
<version>2.6.0</version>
</dependency>
```



### ②service-util添加配置类

创建com.xiaozhi.yygh.common.config.RedisConfig

```java
@Configuration
@EnableCaching      // 开启缓存
public class RedisConfig {

    /**
     * 自定义key规则
     *
     * @return
     */
    @Bean
    public KeyGenerator keyGenerator() {
        return new KeyGenerator() {
            // 定义key的名字：类名+方法名+参数名
            @Override
            public Object generate(Object target, Method method, Object... params) {
                StringBuilder sb = new StringBuilder();     
                sb.append(target.getClass().getName());     // 类名
                sb.append(method.getName());                // 方法名
                for (Object obj : params) {
                    sb.append(obj.toString());              // 参数
                }
                return sb.toString();
            }
        };
    }

    /**
     * 设置RedisTemplate规则
     *
     * @param redisConnectionFactory
     * @return
     */
    @Bean
    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<Object, Object> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);

        //解决查询缓存转换异常的问题
        ObjectMapper om = new ObjectMapper();
        // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);

        //序列号key value
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);

        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }

    /**
     * 设置CacheManager缓存规则
     *
     * @param factory
     * @return
     */
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisSerializer<String> redisSerializer = new StringRedisSerializer();
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);

        //解决查询缓存转换异常的问题
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);

        // 配置序列化（解决乱码的问题）,过期时间600秒
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofSeconds(600))
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))
                .disableCachingNullValues();

        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)
                .cacheDefaults(config)
                .build();
        return cacheManager;
    }
}
```



### ③service-cmn添加redis配置

```properties
spring.redis.host=主机名/IP
spring.redis.port=端口号
spring.redis.password=密码
spring.redis.database= 0
spring.redis.timeout=1800000

spring.redis.lettuce.pool.max-active=20
spring.redis.lettuce.pool.max-wait=-1
#最大阻塞等待时间(负数表示没限制)
spring.redis.lettuce.pool.max-idle=5
spring.redis.lettuce.pool.min-idle=0
```





## 2	使用Spring Cache

### ①常用缓存标签

#### 1、@Cacheable

根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。**一般用在查询方法上**。

查看源码，属性值如下：

| 属性/方法名 | 解释                                             |
| ----------- | ------------------------------------------------ |
| value       | 缓存名，必填，它指定了你的缓存存放在哪块命名空间 |
| cacheNames  | 与 value 差不多，二选一即可                      |
| key         | 可选属性，可以使用 SpEL 标签自定义缓存的key      |



#### 2、@CachePut

使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库。**一般用在新增方法上**。

查看源码，属性值如下：

| 属性/方法名 | 解释                                             |
| ----------- | ------------------------------------------------ |
| value       | 缓存名，必填，它指定了你的缓存存放在哪块命名空间 |
| cacheNames  | 与 value 差不多，二选一即可                      |
| key         | 可选属性，可以使用 SpEL 标签自定义缓存的key      |



#### 3、@CacheEvict

使用该注解标志的方法，会清空指定的缓存。**一般用在更新或者删除方法上**

查看源码，属性值如下：

| 属性/方法名      | 解释                                                         |
| ---------------- | ------------------------------------------------------------ |
| value            | 缓存名，必填，它指定了你的缓存存放在哪块命名空间             |
| cacheNames       | 与 value 差不多，二选一即可                                  |
| key              | 可选属性，可以使用 SpEL 标签自定义缓存的key                  |
| allEntries       | 是否清空所有缓存，默认为  false。如果指定为 true，则方法调用后将立即清空所有的缓存 |
| beforeInvocation | 是否在方法执行前就清空，默认为  false。如果指定为 true，则在方法执行前就会清空缓存 |



### ② 数据字典应用

改造com.atguigu.yygh.cmn.service.impl.DictServiceImpl类方法

```java
    //根据数据id查询子数据列表
    @Cacheable(value = "dict",keyGenerator = "keyGenerator")
    @ApiOperation("根据数据id查询子数据列表")
    @GetMapping("findChildData/{id}")
    public Result findChildData(@PathVariable Long id) {
        List<Dict> dictList = dictService.findChildData(id);
        return Result.ok(dictList);
    }
    
    /**
     * 导入数据字典接口
     * @param file
     * @return
     * 方法调用后清除全部缓存
     */
    @CacheEvict(value = "dict",allEntries = true)
    @ApiOperation("导入数据")
    @PostMapping("importData")
    public Result importDictData(MultipartFile file) {
        dictService.importDictData(file);
        return Result.ok();
    }
```



#### ③测试

我们刷新网页，然后查看redis数据库

![image-20210513161648470](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210513161648470.png)

可以看到生成了一个key，它的名字就是我们之前定义的



# 医院上传接口

## 一、上传医院接口

### 1、 集成mongodb

#### 1.1 添加依赖

service-hosp模块pom.xml添加依赖

```xml
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-data-mongodb</artifactId>
</dependency>
```

 

#### 1.2 添加配置

在application.properties文件添加配置

```properties
spring.data.mongodb.uri=mongodb://192.168.44.165:27017/yygh_hosp
```

说明：改为自己安装mongodb的ip地址 



### 2、 添加医院基础类

#### 2.1 添加model

说明：由于实体对象没有逻辑，我们已经统一导入

com.xiaozhi.yygh.model.hosp.Hospital

#### 2.2 添加Repository

```java
@Repository
public interface HospitalRepository extends MongoRepository<Hospital,String> {
    
}
```

 

#### 2.3 添加service接口及实现类

1，添加com.xiaozhi.yygh.hosp.service.HospitalService接口

```java
public interface HospitalService {
 
}
```



2，添加com.xiaozhi.yygh.hosp.service.impl.HospitalServiceImpl接口实现

```java
package com.atguigu.yygh.hosp.service.impl;

@Service
public class HospitalServiceImpl implements HospitalService {

@Autowired
private HospitalRepository hospitalRepository;

}
```

 

#### 2.4 添加controller

添加com.atguigu.yygh.hosp.api.ApiController

```java
@Api(tags = "医院管理API接口")
@RestController
@RequestMapping("/api/hosp")
public class ApiController {

@Autowired
private HospitalService hospitalService;

}
```

说明：平台对外开发的接口都写在该Controller类



### 3、 上传医院

参考《尚医通API接口文档.doc》业务接口4.1上传医院

医院编号是平台分配的，全局唯一，上传医院接口可以多次调用，如果存在相同编号的为更新操作

#### 3.1 接口数据分析

```json
{
"hoscode": "1000_0",
"hosname": "北京协和医院",
"hostype": "1",
"provinceCode": "110000",
"cityCode": "110100",
"districtCode": "110102",
"address": "大望路",
"intro": "北京协和医院是集医疗、教学、科研于一体的大型三级甲等综合医院，是国家卫生计生委...目标而继续努力。",
"route": "东院区乘车路线：106、...更多乘车路线详见须知。",
"logoData": "iVBORw0KGgoAAAA...NSUhEUg==",
"bookingRule": {
"cycle": "1",
"releaseTime": "08:30",
"stopTime": "11:30",
"quitDay": "-1",
"quitTime": "15:30",
"rule": [
"西院区预约号取号地点：西院区门诊楼一层大厅挂号窗口取号",
"东院区预约号取号地点：东院区老门诊楼一层大厅挂号窗口或新门诊楼各楼层挂号/收费窗口取号"
]
  }
}
```

 **说明**：

1，数据分为医院基本信息与预约规则信息

2，医院logo转换为base64字符串

3，预约规则信息属于医院基本信息的一个属性

4，预约规则rule，以数组形式传递

5，数据传递过来我们还要验证签名，只允许平台开通的医院可以上传数据，保证数据安全性



#### 3.2 添加service接口

1、在HospitalService 类添加接口

```java
/**
 * 上传医院信息
 * @param paramMap
*/
void save(Map<String, Object> paramMap);
```

 

说明：参数使用Map，减少对象封装，有利于签名校验，后续会体验到

2、在HospitalServiceImpl类添加实现

```java
@Override
public void save(Map<String, Object> paramMap) {
    log.info(JSONObject.toJSONString(paramMap));
   Hospital hospital = JSONObject.parseObject(JSONObject.toJSONString(paramMap),Hospital.class);
   //判断是否存在
	Hospital targetHospital = hospitalRepository.getHospitalByHoscode(hospital.getHoscode());
	if(null != targetHospital) {
          hospital.setStatus(targetHospital.getStatus());
          hospital.setCreateTime(targetHospital.getCreateTime());
          hospital.setUpdateTime(new Date());
          hospital.setIsDeleted(0);
        hospitalRepository.save(hospital);
   } else {
//0：未上线 1：已上线
hospital.setStatus(0);
      hospital.setCreateTime(new Date());
      hospital.setUpdateTime(new Date());
      hospital.setIsDeleted(0);
hospitalRepository.save(hospital);
   }
}
```

**说明**：

 Hospital hospital = JSONObject.parseObject(JSONObject.toJSONString(paramMap),Hospital.class);

Map转换为Hospital对象时，预约规则bookingRule为一个对象属性，rule为一个数组属性，因此在转换时我们要重新对应的set方法，不然转换不会成功



```java
public class Hospital extends BaseMongoEntity {

private static final long serialVersionUID = 1L;

@ApiModelProperty(value = "医院编号")
private String hoscode;

...

//预约规则
@ApiModelProperty(value = "预约规则")
private BookingRule bookingRule;

public void setBookingRule(String bookingRule) {
this.bookingRule = JSONObject.parseObject(bookingRule, BookingRule.class);
   }

}
```

```java
public class BookingRule {

@ApiModelProperty(value = "预约周期")
private Integer cycle;

...

@ApiModelProperty(value = "预约规则")
private List<String>rule;

/**
    *
    * @param rule
*/
public void setRule(String rule) {
if(!StringUtils.isEmpty(rule)) {
this.rule = JSONArray.parseArray(rule, String.class);
      }
   }

}
```

 

#### 3.3 添加repository接口

在HospitalRepository类添加接口

```java
Hospital getHospitalByHoscode(String hoscode);
```

 

#### 3.4 添加controller接口

在ApiController类添加接口

```java
@ApiOperation(value = "上传医院")
@PostMapping("saveHospital")
public Result saveHospital(HttpServletRequest request) {
      Map<String, Object> paramMap = HttpRequestHelper.switchMap(request.getParameterMap());
	hospitalService.save(paramMap);
	return Result.ok();
}
```

 

#### 3.5 添加帮助类

在service-util模块添加HttpRequestHelper帮助类

```java
package com.xiaozhi.yygh.common.helper;

@Slf4j
public class HttpRequestHelper {

/**
     *
     * @param paramMap
* @return
*/
public static Map<String, Object> switchMap(Map<String, String[]> paramMap) {
        Map<String, Object> resultMap = new HashMap<>();
for (Map.Entry<String, String[]> param : paramMap.entrySet()) {
            resultMap.put(param.getKey(), param.getValue()[0]);
        }
return resultMap;
    }
}
```

 

#### 3.6 测试

打开我们的医院管理系统，将医院的信息上传到我们的MongoDB数据库中

![image-20210520172342056](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210520172342056.png)

![image-20210520172409429](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210520172409429.png)

将演示的数据复制到里面去，然后点击保存即可！

**查看MongoDB数据库**

![image-20210520172454784](https://xiaozhi-blog.oss-cn-guangzhou.aliyuncs.com/img/image-20210520172454784.png)





### 4、 参数签名

参考《尚医通API接口文档.doc》业务接口3.1传参说明

#### 4.1 封装签名方法

在service-util模块HttpRequestHelper类添加方法

```java
public static void main(String[] args) {
    Map<String, Object> paramMap = new HashMap<>();
    paramMap.put("d", "4");
    paramMap.put("b", "2");
    paramMap.put("c", "3");
    paramMap.put("a", "1");
    paramMap.put("timestamp", getTimestamp());
    log.info(getSign(paramMap, "111111111"));
}


/**
 * 请求数据获取签名
 * @param paramMap
* @param signKey
* @return
*/
public static String getSign(Map<String, Object> paramMap, String signKey) {
    if(paramMap.containsKey("sign")) {
            paramMap.remove("sign");
    }
    TreeMap<String, Object> sorted = new TreeMap<>(paramMap);
    StringBuilder str = new StringBuilder();
    for (Map.Entry<String, Object> param : sorted.entrySet()) {
        str.append(param.getValue()).append("|");
    }
    str.append(signKey);
    log.info("加密前："+ str.toString());
        String md5Str = MD5.encrypt(str.toString());
    log.info("加密后："+ md5Str);
    return md5Str;
}

/**
 * 签名校验
 * @param paramMap
* @param signKey
* @return
*/
public static boolean isSignEquals(Map<String, Object> paramMap, String signKey) {
    String sign = (String)paramMap.get("sign");
    String md5Str = getSign(paramMap, signKey);
    if(!sign.equals(md5Str)) {
    return false;
        }
    return true;
}

/**
 * 获取时间戳
 * @return
*/
public static long getTimestamp() {
    return new Date().getTime();
}
```

 

#### 4.2 上传医院添加签名校验

我们在医院设置的时候，为每个医院生成了医院编码与签名key，因此我在验证签名时要根据医院编码去动态获取签名key，然后再做签名校验

##### 4.2 .1 添加获取签名key接口

1，在HospitalSetService类添加接口

```java
/**
 * 获取签名key
 * @param hoscode
* @return
*/
String getSignKey(String hoscode);
```

 

2，在HospitalSetServiceImpl类实现接口

```java
@Override
public String getSignKey(String hoscode) {
   	HospitalSet hospitalSet = this.getByHoscode(hoscode);
    if(null == hospitalSet) {
    	throw new YyghException(ResultCodeEnum.HOSPITAL_OPEN);
    }
    if(hospitalSet.getStatus().intValue() == 0) {
        throw new YyghException(ResultCodeEnum.HOSPITAL_LOCK);
    }
    return hospitalSet.getSignKey();
}

/**
 * 根据hoscode获取医院设置
 * @param hoscode
* @return
*/
private HospitalSet getByHoscode(String hoscode) {
    return hospitalSetMapper.selectOne(new QueryWrapper<HospitalSet>().eq("hoscode", hoscode));
}
```

 

##### 4.2.2 修改ApiController类上传医院接口

修改ApiController类上传医院接口

```java
@ApiOperation(value = "上传医院")
@PostMapping("saveHospital")
public Result saveHospital(HttpServletRequest request) {
   	Map<String, Object> paramMap = HttpRequestHelper.switchMap(request.getParameterMap());
    //必须参数校验 略
    String hoscode = (String)paramMap.get("hoscode");
    if(StringUtils.isEmpty(hoscode)) {
    	throw new YyghException(ResultCodeEnum.PARAM_ERROR);
    }
    //签名校验
    if(!HttpRequestHelper.isSignEquals(paramMap, hospitalSetService.getSignKey(hoscode))) {
    	throw new YyghException(ResultCodeEnum.SIGN_ERROR);
    }
	hospitalService.save(paramMap);
    return Result.ok();
}
```

 



































