# 体系班 -> 进阶版17-48-> 大厂班

# 干干干！！！

# 一、复杂度

## 操作

首先呢，我们将程序分为两种操作，常数操作和非常数操作



### 常数项操作

固定时间的操作

![image-20230111221427823](E:\学习笔记\img\image-20230111221427823.png)

数组是一个地址连续的存储结构，通过下角标我们可以快速的获取值，它可以通过偏移量就可以计算它的位置，然后获取出来，那么这种可计算的操作就是固定时间的操作，常数项操作复杂度用`O(1)`表示

再比如算数运算、变量赋值等操作。



### 非常数项操作

常数操作是固定时间操作，那么非常数操作就和它相反了

![image-20230111221552949](E:\学习笔记\img\image-20230111221552949.png)

这是一个跳转结构，通过指针指向下一个节点形成的结构，那么它的内存不是连续的，那么就不能使用偏移量来计算，这个时候就需要去查找对应指向的地址，所以这个时间是确定的，那么这个就是常数操作





## 评价算法优劣的核心指标

### 时间复杂度

为什么需要时间复杂度这个东西去衡量算法呢，我们不能在计算机上直接跑吗，谁快谁就好呗，我猜很多人都是这样想吧，但是大家有没有想过不同的机器跑出来的效果是不一样的，性能快的和性能差的执行同一个算法，结果肯定是性能快的更快执行完，那么这个时候如何去衡量呢，有人肯定又会说，我们使用同样性能的去跑不就可以了吗？但是我们在设计算法的时候，并不是一次性就能够设计出来，需要经过大量的测试才是一个算法，那么在这种情况下，如果每次都去跑大量数据，耗费的精力和时间是不可估量的，所以我们在编写算法的时候可以通过估量时间复杂度来衡量算法的好坏，时间复杂度是衡量算法的最重要的指标。

那么什么是时间复杂度呢，我们先看几个例子

```java
for(int i=0; i < 5; i++) {
	System.out.println("输出：" + i);
}
```

输出5次，五次常数项操作，那么它的时间复杂度为`O(1)`

```java
public void sout(int n) {
	for(int i=0; i < n; i++) {
		System.out.println("输出：" + i);
	}
}
```

输出n次，N次常数项操作，它的时间复杂度为`O(n)`

时间复杂度就是将常数项的次数进行抽象，用量级来表示算法的好坏程度。



#### 推导时间复杂度的原则

1.  常数操作，用`O(1)`表示
2.  只保留函数中的最高阶项

    对程序影响最大的操作，其他的忽略
3.  去掉最高阶项的系数
4.  ==时间复杂度的推导是在最坏的情况下==



#### 举个例子：选择排序

**排序思想**：从全部数中选择最小值依次放入，从1开始，遍历n-1次，最后以此不用选，因为它就是最大的

![image-20230111234542477](E:\学习笔记\img\image-20230111234542477.png)

假设找到最小值是下角标为5的元素，那么就将5和0位替换，接下来不用管0位置，继续找最小值，找到放入1位置，以此类推找到最小值放到前面。





**代码实现**

```java
public void selectSort(int arr[]) {
    // 边界检查
    int len = arr.length;
    if (arr == null || len < 2) {
        return;
    }
    // 外层循环控制次数 n-1次 -> 最后一个不用选
    for(int i=0; i < len - 1; i++) {
        // 最小值下角标位置
        int minIndex = i;
        // 内层循环控制比较的次数，已经找出来的就不用比较
        for(int j=i + 1; j < len; j++) {
            // 如果最小值大于当前值，那么当前值为最小值
            if (arr[minIndex] > arr[j]) {
                minIndex = j;
            }
        }
        // 将最小值放到前面
        swap(arr, i, minIndex);
    }
}

/**
	 * 	将数组中两个位置的元素调换
	 * @param arr
	 * @param a
	 * @param b
	 */
public void swap(int[] arr, int a, int b) {
    int temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
}
```





### 额外空间复杂度

两者功能一样，时间复杂度也一样，那么就要通过额外空间复杂度来评估。

在实现功能所借助的额外空间的多少就是空间复杂度

举个例子：假设我们现在需要获取数组中出现最多次的元素，如果我们建立一个映射表map来记录的话，那么这个map表就是额外的空间，元素是n个，那么它的空间复杂度就是`O(n)`

![image-20230112210747915](E:\学习笔记\img\image-20230112210747915.png)

但是，如果要求是用额外空间返回数据，那么这个时候是不计入额外空间复杂度的，比如返回一个数组的拷贝



### 常数项

常数项就是固定时间的操作





## 对数器

设计的两种不同方案进行大量数据测试，如果程序出现不同的地方，这个时候就要检查算法那里不对，然后重新设计再测试

**比如**：我写一个排序的算法，我们可以使用系统中已经存在的成熟的算法进行比较，当结果出现不一致时，那么就是算法出错了。

***代码实现***

用上面我们自己编写的插入排序来和系统的排序方法进行测试

-   首先需要生成大量随机数据和大量次数测试
-   然后两者每一次都比较一次，当出现错误时就停止程序并输出两个数组

```java
public class InsertSort {
	
	public static void insertSort(int arr[]) {
		// 边界检查
		int len = arr.length;
		if (arr == null || len < 2) {
			return;
		}
		// 从1开始，从0开始没意义
		for(int i=1; i < len; i++) {
			// j是大于0的，因为是和前一个比较，也就是j-1，j=0就越界了
			for(int j=i; j > 0 && arr[j] < arr[j-1]; j--) {
				// 判断是否小于，小于交换
				swap(arr, j, j-1);
			}
		}
	}
	
	public static void swap(int[] arr, int a, int b) {
		int temp = arr[a];
		arr[a] = arr[b];
		arr[b] = temp;
	}
	
	/**
	 *     生成随机数
	 */
	public static int[] generateRandomArray(int maxSize, int maxValue) {
		// 次数和最大值随机
		int[] arr = new int[(int)((maxSize + 1) * Math.random())];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int)((maxValue + 1) * Math.random()) - (int)((maxValue) * Math.random());
		}
		return arr;
	}
	
	/**
	 * 比较两个数组
	 */
	public static boolean isEquals(int[] arr1, int[] arr2) {
		if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
			return false;
		}
		if (arr1.length != arr2.length) {
			return false;
		}
		if (arr1 == null && arr2 == null) {
			return true;
		}
		for (int i = 0; i < arr1.length; i++) {
			if (arr1[i] != arr2[i]) {
				return false;
			}
		}
		return true;
	}
	
	public static void printArr(int[] arr) {
		for(int d : arr) {
			System.out.print(d);
		}
		System.out.println();
	}
	
	public static void main(String[] args) {
		int testTime = 500000;
		int maxSize = 100; 		// 随机数组的长度0～100
		int maxValue = 100;		// 值：-100～100
		for (int i = 0; i < testTime; i++) {
			int[] arr = generateRandomArray(maxSize, maxValue);
			int[] arr1 = Arrays.copyOf(arr, arr.length);
			int[] arr2 = Arrays.copyOf(arr, arr.length);
			insertSort(arr1);
			Arrays.sort(arr2);
			if (!isEquals(arr1, arr2)) {
				System.out.println("fuck~~~");
				System.out.println(Arrays.toString(arr1));
				System.out.println(Arrays.toString(arr1));
				return;
			}
		}
		System.out.println("nice~~~");
	}
}
```







# 二、位运算

底层的运算，将数转成二进制，然后再进行计算。

比如 1 << 3，`<<`是左移符号，1左移了三位

1.  先将1转成二进制，假设是8为的数，结果是 0000 0001
2.  左移3位变成 0000 1000，转成十进制就是8

**总结**：位运算就是在二进制层面进行操作。



## 与运算

都是1则为1，有一个为0则为0，全部为1则为1，和逻辑与一样的逻辑



### ①输出int类型的数的二进制

```java
public static void printBinary(int num) {
	for (int i = 31; i >= 0; i--) {
		System.out.print((num & (1 << i)) == 0 ? "0" : "1");
	}
}
```





## 或运算

有一个为1则结果为1



**将二进制转化为十进制输出**

```java
public static void BinaryToDecimal(String num) {
    int sum = 0;
    for (int i = 0; i < num.length(); i++) {
        // 如果为1
        String val = String.valueOf(num.charAt(i));
        if("1".equals(val)) {
            int index = 2;
            // 左移31 - i位
            sum |= 1 << (31 - i);
        }
    }
    System.out.println(sum);
}
```





## 异或

两个数相同就为0，不同就为1

```java
// 例子 - 两个int类型的数进行异或
数值  二进制
13 -> 00000000000000000000000000001101
29 -> 00000000000000000000000000011101
      00000000000000000000000000010000
结果：16
```



***异或三定律***

-   `N ^ N`=0，因为都是相同的，所以全为0，结果=0

-   `N ^ 0`=N

    ```java
    13 -> 00000000000000000000000000001101
    0  -> 00000000000000000000000000000000
          00000000000000000000000000001101
    // 因为1和0为不同，所以结果位为1,0和0相同，异或结果位为0
    ```

-   多个数异或最终结果只有一个

    ```java
    13 ->  00000000000000000000000000001101
    29 ->  00000000000000000000000000011101
    60 ->  00000000000000000000000000111100
    78 ->  00000000000000000000000001001110
    结果-> 00000000000000000000000001100010
    ```

    <img src="E:\学习笔记\img\image-20230129204121145.png" alt="image-20230129204121145" style="zoom:50%;" />

    | 1的个数 | 0的个数 | 结果 |
    | ------- | ------- | ---- |
    | 2       | 2       | 0    |
    | 4       | 0       | 0    |
    | 4       | 0       | 0    |
    | 2       | 2       | 0    |

    **结论**：多个数异或，偶数次出现的1或0结果为0，奇数次出现的1结果为1



### ①变量交换

如何不适用额外变量就将变量进行交换，答案是使用异或

```java
public static void swap(int[] arr, int a, int b) {
	arr[a] = arr[a] ^ arr[b];
	b = arr[a] ^ arr[b];
	a = arr[a] ^ arr[b];
}
```

**分析**：

-   第一步 a = a ^ b
-   第二步 b = a ^ b，此时的a=a ^ b（第一步），所以 b = a ^ b ^ b，根据异或定律，b是双数，异或为0，所以结果是a
-   第三步 a = a ^ b，此时的a还是=a ^ b（第一步），b为a(第二步)，所以 a = a ^ b ^ a=b

==**注意**：排序在使用位运算这种方式交换的话要注意两个数不能为同一个，如果为同一个，那么结果为0，异或的三大定律，所以要注意这个问题！！！==



### ②寻出现奇数次的数

**题1：获取数组中出现奇数次的数**

***分析***：根据异或三定律，多个数异或，出现偶数次的必然为0，出现奇数次的为1，那么要找到出现奇数次的数就是需要将所有的数异或，最终结果就是出现奇数次的数了。

<img src="E:\学习笔记\img\image-20230130214727005.png" alt="image-20230130214727005" style="zoom:80%;" />

**代码实现**

```java
public class code02_GetOddNum {
		
	public static int OddNum(int[] arr) {
		int num = 0;
		for (int i = 0; i < arr.length; i++) {
			// 挨个异或
			num ^= arr[i];
		}
		return num;
    }
}
```



**题2：怎么把一个int类型的数，提出最右侧的1出来**

**例题**：10的二进制为`1010`，提出最右侧1的值为`0010`，结果为2

**思路**：将最后一个1的左右两边反转，接着再与上原始数据

![image-20230223124531082](E:\学习笔记\img\image-20230223124531082.png)

这里省略了前面的1

**解析**：

最右侧1用`它`表示

1.  反转78，它也反转，需要将它反转回来
2.  +1将它反转回来，因为它的左侧都是1，所以+1之后它重新变为1，它的左边都为0
3.  接下来将`反转+1`的数和原始数进行与运算，因为它的右边是反转过的，所以与的结果为0，又因为它的右边全部都是0，所以也为0，那么结果就是最右侧的1被提取出来了

![image-20230223125533078](E:\学习笔记\img\image-20230223125533078.png)



**代码实现**

```java
public class code03_LastOne {

	public static int lastOne(int num) {
		return (~num + 1) & num;
	}
}
```



**题3：数组中有两种数出现奇数次，其他数都出现偶数次，找到并打印这两种数**

**分析**：

1.  偶数次的数异或就没了，剩下的就是奇数的了

2.  如何将两个异或的奇数拆分出来？

    首先我们要知道的是这两个数肯定是不一样的，那么他们的二进制数也是不一样的，肯定存在某个位上有1和0

    ![image-20230309135858930](E:\学习笔记\img\img01\image-20230309135858930.png)

    0和1异或的结果为1，也就是说两个奇数异或的结果中为1的就是存在两个不同的数

    本例子中我们选择将最右边的1提取出来，当然也可以将其他位置的1提取出来。

3.  提取出来之后又如何找到我们要的奇数呢？

    这里我们就要明确它的特性，它是一个奇数，而另外一个奇数是和这个奇数在当前位上存在差异，所以我们只需要将数组中所有存在`结果提取出来的最右侧1`相同位置的数进行异或，异或的结果就是我们其中一个奇数，因为偶数异或为0了

    ![image-20230309141308083](E:\学习笔记\img\img01\image-20230309141308083.png)



**代码实现**

```java
/**
 * @param arr 数组中有两种奇数，出现次数为偶数，其他数都出现偶数次
 * @return 两个奇数
 */
public static int[] OddNums(int[] arr) {
    // 获取异或的结果 -> 结果为两个奇数次的数异或
    int sum = 0;
    for (int i = 0; i < arr.length; i++) {
        sum ^= arr[i];
    }
    // 将最右侧的1提取出来
    int farRightOne = (~sum + 1) & sum;
    // 将最右侧1的结果再和所有数异或，最后结果就是两个奇数次的数的其中一个
    int firstRes = 0;
    for (int i = 0; i < arr.length; i++) {
        if ((arr[i] & farRightOne) != 0) {
            firstRes ^= arr[i];
        }
    }
    // 最后将异或总结果和得到的奇数次的数异或，就可以得到第二个奇数次的数
    int secondRes = sum ^ firstRes;
    return new int[]{firstRes, secondRes};
}
```





### ③找出现K次的数

**题1：一个数组中有一种数出现k次，其他数都出现了M次，M>1，K<M，找到出现了K次的数**

**要求**：额外空间复杂度`O(1)`，时间复杂度`O(N)`

**分析**：题目要求就是不让我们使用Hash表来实现

1.  观察题目发现，都是和次数相关的，只要两种次数。所以我们可以记录他们二进制位的出现的次数
2.  遍历数组，将对应位置的数进行模运算，模上M不等于0的就说明存在K次的数
3.  将对一个位置的数放入到二进制位中，将1进行位运算，移动到对应的位置，接着再进行或运算将它放入到结果中

**代码**

```java
public static int findKNum(int[] arr, int k, int m) {
    // 1 定义int长度的数组作为计数数组
    int[] countArr = new int[32];
    // 2 遍历数据数组，将对应数据位中有1 的数累加到计数数组对应位上
    for (int i=0; i < arr.length; i++) {
        // 遍历32次，所以还是O(n)
        for (int j=0; j < 32; j++) {
            // 如果对应位不为0，则累加到计数数组中
            if ((arr[i] & (1 << j)) != 0) {
                // 对应位 +1
                countArr[j] += 1;
            }
        }
    }
    // 3 求出那些位上有K值的1，接着将它放入到二进制位中
    int kNum = 0;
    for (int i = 0; i < countArr.length; i++) {
        // 如果次数模上m不为0，则此位置必然存在k的位
        if (countArr[i] % m != 0) {
            // 进行或运算将1放入
            kNum |= 1 << i;
        }
    }
    return kNum;
}
```





**题2：在题一的基础上修改条件，假设K可能为0**

```java
public static int findKNum(int[] arr, int k, int m) {
    // 1 定义int长度的数组作为计数数组
    int[] countArr = new int[32];
    // 2 遍历数据数组，将对应数据位中有1 的数累加到计数数组对应位上
    for (int i=0; i < arr.length; i++) {
        // 遍历32次，所以还是O(n)
        for (int j=0; j < 32; j++) {
            // 如果对应位不为0，则累加到计数数组中
            if ((arr[i] & (1 << j)) != 0) {
                // 对应位 +1
                countArr[j] += 1;
            }
        }
    }
    // 3 求出那些位上有K值的1，接着将它放入到二进制位中
    int kNum = 0;
    for (int i = 0; i < countArr.length; i++) {
        if (countArr[i] % m == 0) {
            continue;
        }
        // 模上等于k才证明k不是0
        if (countArr[i] % m == k) {
            // 进行或运算将1放入
            kNum |= 1 << i;
        } else {
            return -1;
        }
    }
    return kNum;
}
```









# 三、基础的数据结构

## 链表

### [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

#### 无虚拟头节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        while (head != null && head.val == val) {
            head = head.next;
        }
         if (head == null) return head;
        ListNode pre = head;
        while (pre.next != null) {
            if (pre.next.val == val) {
                // 删除当前节点
                pre.next = pre.next.next;
            } else {
                pre = pre.next;
            }
        }
        return head;
    }
}
```

**注意**：题目中只有一个ListNode，并没有用到虚拟节点，所以需要开始就定一个做为头节点，假设`val`为头节点最后的结构就是错的，所以需要将前面的`val`都删除，剩下就值就不会是`val`，情况如下：

![image-20230506231632089](E:\学习笔记\img\img01\image-20230506231632089.png)



#### 有虚拟头节点

这种方式就不需要考虑头节点的问题

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        /*  有虚拟节点方式  */
        if (head == null) {
            return head;
        }
        // 定义一个虚拟节点
        ListNode xuni = new ListNode(-1, head);
        ListNode pre = xuni;
        ListNode current = xuni.next;
        while (current != null) {
            if (current.val == val) {
                pre.next = current.next;
            } else {
                pre = current;
            }
            current = current.next;
        }
        return xuni.next;
    }
}
```





### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

![image-20230312101708841](E:\学习笔记\img\img01\image-20230312101708841.png)





## 栈和队列

分别使用链表和数组实现

栈有压栈和入栈两种操作方式，遵循先入后出的规律。

队列有入队和出队两种方式，遵先入先出的规律，和排队一样。



### 链表实现

**栈实现**

首先我们需要知道链表的特点是需要通过循环来找到前面的节点或者后面的节点，接着将指针指向需要添加的元素节点，栈是先入后出，也就是说，每次我们只需要获取后面添加的元素就好了，那么提供以下两种思路：

1.  单链表实现：每次添加新元素时使用头指针指向新添加的节点，新添加的节点再指向之前头指针指向的节点，以此完成添加元素的操作。获取元素的时候只需要获取头节点指向的那个节点即可

    ![image-20230508204411691](E:\学习笔记\img\img01\image-20230508204411691.png)

2.  双链表实现：和单链表的方式差不多

```java
/**
 * 单链表实现栈
 * 这里使用单链表的形式实现 -> 头插法
 * 
 * @author XIAOZHI
 *
 */
public class Code02_ListToStack {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Stack stack = new Stack();
		stack.push(1);
		stack.push(3);
		System.out.println(stack.pop());
		System.out.println(stack.pop());
	}
}

class Stack {
	
	// 记录总数
	int size;
	Node node;
	public Stack() {
		this.node = new Node(0);
		this.size = 0;
	}
	
	// 出栈
	public int pop() {
		// 边界检查 -> 当size为0则直接返回
		if (size == 0) {
			return -1;
		}
		// 获取第一个元素，将第一个元素弹出，头节点移到第一个元素的下一个元素
		Node resultNode = node.next;
		node.next = node.next.next;
		return resultNode.element;
	}
	
	
	// 压栈 -> 使用头插法的方式插入新的元素
	public void push(int element) {
		Node newNode = new Node(element);
		// 新元素的下一个元素是上一个的第一个元素
		newNode.next = node.next;
		node.next = newNode;
		size++;
	}
	
	static class Node {
		int element;
		Node next;
		public Node() {}
		public Node(int element) {
			this.element = element;
		}
	}
}
```



**队列实现**

队列的规律是先入先出，使用双链表实现，头指针指向第一个加入的，尾指针指向最后一个加入的，取值的时候只需要获取头节点指向的节点即可。

![image-20230508205131992](E:\学习笔记\img\img01\image-20230508205131992.png)

```java

```







### 数组实现

**实现栈**

使用一个索引(`index`)来标识最后一个元素，弹出就是将指向的元素弹出即可

```java

```



**实现队列**

数组是一个定长的容器，也就是说空间是固定的，在固定的空间里需要考虑空余的空间，我们可以：

-   使用 `start` 指针指向开头元素

-   使用 `end` 指针指向尾部元素

-   另外需要一个变量 `size` 来控制元素的个数，这是因为我们的空间是固定的，在元素不断的加入和弹出的情况下，会形成循环的效果，每次添加元素的时候都需要考虑 下一个元素 是否已经存在元素了，而加`size`来控制就可以直接知道是否还可以添加元素或者弹出元素了。

    ![image-20230508211730979](E:\学习笔记\img\img01\image-20230508211730979.png)

```java

```





### [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

用两个栈就可以实现队列的效果

1.  栈1：一个栈用来存元素
2.  栈2：一个栈用来出元素

实现：将 栈1 的元素全部倒入到 栈2 中，再将 栈2 出栈，此时 栈1 最后的元素就是 栈2 的头元素

```java

```



### [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

使用两个队列来实现队列栈





# 排序

## [912. 排序数组](https://leetcode.cn/problems/sort-an-array/)

### 冒泡排序

时间复杂度`O(n^2)`

**代码实现**



### 插入排序

![image-20230112124625611](E:\学习笔记\img\image-20230112124625611.png)

**排序思路**：首先插入排序的核心就是判断当前元素是否比前面的所有元素小，如果是，那么就和前面的元素位置进行交换，如果不是，那么不用动，因为前面序列是有序的。

| 第几次循环 | 执行结果                   |
| ---------- | -------------------------- |
| 第1次      | 1和2比较，1小，和2交换位置 |
| 第2次      | 4比前面的都大，不交换      |
| 第3次      | 3比4小，交换               |
| 第4次      | 5比前面都大，不交换        |

这种情况是比较好的情况，算法评估是在最差的情况考虑的，接下来我们看一下最坏的情况

*最坏情况*：每一次都要将当前元素放到第一位

![image-20230112125019935](E:\学习笔记\img\image-20230112125019935.png)



| 第几次循环 | 执行结果                                      |
| ---------- | --------------------------------------------- |
| 第1次      | ①4<5，交换                                    |
| 第2次      | ①3<5，交换 ②3<4，交换                         |
| 第3次      | ①2<5，交换 ②2<4，交换 ③2<3，交换              |
| 第4次      | ①1<5，交换 ②1<4，交换 ③1<3，交换，④1<2，交换x |

所以，选择选择排序的时间复杂度是`O(n^2)`



***代码实现***

```java
class Solution {
    public int[] sortArray(int[] nums) {
        // 边界校验
        if (nums == null || nums.length < 2) return nums; 
        // 插入排序
        for (int i=1; i < nums.length; i++) {
            for(int j=i; j > 0 && nums[j] < nums[j-1]; j--) {
                // 如果比前面的小就要进行交换
                swap(nums, j, j-1);
            }
        }
        return nums;
    }

    public void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```



### 选择排序

**排序思想**：从全部数中选择最小值依次放入，从1开始，遍历n-1次，最后以此不用选，因为它就是最大的

![image-20230111234542477](E:\学习笔记\img\image-20230111234542477.png)

假设找到最小值是下角标为5的元素，那么就将5和0位替换，接下来不用管0位置，继续找最小值，找到放入1位置，以此类推找到最小值放到前面



**代码实现**

```java
public void selectSort(int arr[]) {
    // 边界检查
    int len = arr.length;
    if (arr == null || len < 2) {
        return;
    }
    // 外层循环控制次数 n-1次 -> 最后一个不用选
    for(int i=0; i < len - 1; i++) {
        // 最小值下角标位置
        int minIndex = i;
        // 内层循环控制比较的次数，已经找出来的就不用比较
        for(int j=i + 1; j < len; j++) {
            // 如果最小值大于当前值，那么当前值为最小值
            if (arr[minIndex] > arr[j]) {
                minIndex = j;
            }
        }
        // 将最小值放到前面
        swap(arr, i, minIndex);
    }
}

/**
	 * 	将数组中两个位置的元素调换
	 * @param arr
	 * @param a
	 * @param b
	 */
public void swap(int[] arr, int a, int b) {
    int temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
}
```







# 技巧

## 编码技巧

### 位运算比算数运算更快







## 二分法

二分法，通过不断减半的方式获取想要的值，无论是有序或者无序的序列都可以用二分法，看你的数据状态决定是否使用

比如：

-   有序序列中，要查询某一个值的话，要么比它大，要么比它小，所以数据只有两种状态
-   无序序列中，如果数据存在两种状态，那么也是可以二分法的



### 查找最小值

*需求*：有序数组，判断元素是否存在该数组中

*分析*：有序数组，元素从小到大排序，那么如果中间值大于查找元素值，那么查找值必不可能在右边，所以往左找，那么将右指针移到中间值的前一位，接着计算左到右的中间值，再次比较，以此循环，最终左和右重合或者左指针在右指针的右边就表示结束。

*核心*：每次减一半，获取中间值，比较中间值

-   小于中间值，往左边找
-   大于中间值，往右边找

![image-20230112213608198](E:\学习笔记\img\image-20230112213608198.png)

***代码实现***

```java
public static boolean dataIfExit(int[] arr, int data) {
	int left = 0;
	int right = arr.length - 1;
	// 边界检查
	if (arr == null || arr.length == 0) {
		return false;
	}
	// 元素在头或尾存在
	if (arr[left] == data || arr[right] == data) {
		return true;
	}
	// 当左指针在右指针的右边，说明数组已经查找完毕
	while (left <= right) {
		int mid = left + ((right - left) >> 1);
		if (data < arr[mid]) {
			right = mid - 1;
		} else if (data > arr[mid]) {
			left = mid + 1;
		} else {
			return true;
		}
	}
	return false;
}
```



### 最左或最右元素匹配

以左边为例

*需求*：有序数组中找>=value的最左位置，找到返回下角标，没找到返回-1

例子： [1,2,2,2,3,4,5]，value为2，最左位置为 1 

*分析*：和前面查找最小值一样的方式，但是每次查找到元素值都需要比对，看谁的位置更加贴近左边



***代码实现***

```java
public static int nearestIndex(int[] arr, int data) {
	int L = 0;
	int R = arr.length - 1;
	int index = -1;
	if (arr == null || arr.length == 0) {
		return index;
	}
	while (L <= R) {
		int mid = L + ((R - L) >> 1);
         // >=data，index变化，范围往左缩小
		if (arr[mid] >= data) {
			R = mid - 1;
			index = mid;
		} else {
			L = mid + 1;
		}
	}
	return index;
}
```



### 局部最小值

*需求*：获取局部最小值的位置

*例子*：

-   [ 0 , 1 , ...... ]，局部最小为0
-   [ ...... , 4 , 2 ]，局部最小为2
-   [ ......, 8 , 4 , 7,  ...... ]，局部最小为4

分析：

①当元素不是边边的时候，他们的元素趋势如下，两边都是下降，从左看，左边是下降，从右边看，右边是下降

==**下降或上升是看你是从那边看，只要两边指向中间的都是下降，那么它就是局部最小值**==

![image-20230116230451799](E:\学习笔记\img\image-20230116230451799.png)

②当元素是中间值时的趋势，左右两边都是下降的趋势，这个时候就是我们要找的局部最小值，记住现在的状态

![image-20230116230635381](E:\学习笔记\img\image-20230116230635381.png)

③我们再来看看既不是两边，也不是当前中间值的趋势

下图左边和中间的趋势和`②`中的趋势一样，局部最小值在左边

![image-20230116231411072](E:\学习笔记\img\image-20230116231411072.png)

已上图为例，4-2是下降，6 -> 3是下降，3 -> 2是下降，所以2是局部最小值 [ 4 2 3 ]

我们来假设一下，**假设2 ->3是下降**，那么3是不是就是局部最小值，[ 2 1 6 ]

以此类推，当两边趋势都是下降，那么它必然存在局部最小值

==**得出结论**：只要两边存在两个下降的趋势，那么局部最小值一定是在这一遍==



**代码实现**

只要保证趋势存在，那么一定能找到最小值，用二分法依次减少

```java
/**
   *   局部最小值
 * @param arr
 * @return
 */
public static int getLessIndex(int[] arr) {
	int L = 1;
	int R = arr.length - 2;
	// 如果只有一个数，返回-1
	if (arr == null && arr.length == 0	) {
		return -1;
	}
	if (arr.length == 1 || arr[0] < arr[1]) {
		return 0;
	}
	if (arr[arr.length - 2] > arr[arr.length - 1]) {
		return arr.length - 1;
	}
	while (L <= R) {
		// 看中间值
		int mid = L + ((R -L) >> 1);
		if (arr[mid] > arr[mid - 1]) {
			R = mid - 1;
		} else if (arr[mid] > arr[mid + 1]) {
			L = mid + 1;
		} else {
			return mid;
		}
	}
	return -1;
}
```





















