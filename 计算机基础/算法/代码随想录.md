# 一、数组

## 1	数组理论基础

-   数组是存放在连续内存空间上的**相同类型数据**的集合
-   数组内存空间的地址是连续的
    -   因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就会移动到其他元素
-   数组的元素是不能删的，只能覆盖

**注意**：java的数组可能不是连续的





## 2	二分法查找

### ①题目

[力扣题目链接](https://leetcode-cn.com/problems/binary-search/)

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 


示例 1: 

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

示例 2:

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```


提示：

你可以假设 nums 中的所有元素是不重复的。
n 将在 [1, 10000]之间。
nums 的每个元素都将在 [-9999, 9999]之间。



### ②解题思路

1.  首先二分法查找它是一个有序数组，所以一开始可以判断元素是否在区间内，不在就返回-1
2.  通过左右区间值判断循环是否继续
    1.  中间值：middle = left + (right - left) >> 1
    2.  如果target > middle ，整个区间就变成右区间
    3.  如果target < middle ，整个区间就变成左区间
    4.  如果target = middle ，输出middle（我们就是通过这个来找到对应的值，没有找到就会继续往下找）
3.  最终就是只剩一个元素，要么找到了，要么找不到

![image-20211227115705564](E:\学习笔记\img\20211227115706.png)



### ③代码实现

```java
class Solution {
    public int search(int[] nums, int target) {
        // 首先是判断是否在区间内，不在就直接返回-1
        if (target < nums[0] || target > nums[nums.length - 1]) {
            return -1;
        }
        int left = 0;
        int right = nums.length - 1;
        // 区间内判断 --> 大于中间值，那么就往右边走，否则往左边走
        while ( left <= right ) {    // 要考虑到只有一个元素的情况
            // 中间值
            int middle = left + (right - left) >> 1;
            // 大于目标值的话就往左边走
            if (nums[middle] > target) {
                right = middle -1;  // left不变，right要变成中间值-1，变成左边区间
            } else if (nums[middle] < target) {
                left = middle + 1;  // right不变，left变成中间值-1，变成右边区间
            } else {    // 中间值就是target
                return middle;
            }
        }
        return -1;
    }
}
```





## 3	移除元素

### ①题目

[力扣题目链接](https://leetcode-cn.com/problems/remove-element/)

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

==**解释**：就是不能使用新的数组，然后将元素复制到新的数组中==

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**说明**:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```


示例 1：

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

示例 2：

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```


提示：

0 <= nums.length <= 100
0 <= nums[i] <= 50
0 <= val <= 100



### ②思路

不能使用新的数组，那么我们有两种做法：

-   暴力解法：发现需要移除的元素，那么我们就整体往前覆盖
-   双指针法：将不是要移除的元素往前放，通过下标指针来控制(index)，最终返回index，也就是不是移除元素的长度



### ③代码实现

**暴力解法**

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        // 暴力解法
        int len = nums.length;
        for(int i = 0; i < len; i++) {
            // 发现需要移除的元素就往前移动进行覆盖
            if (nums[i] == val) {
                // j=i+1是为了防止下角标越界
                for (int j=i+1; j < len; j++) {
                    // 后面的覆盖前面的
                    nums[j - 1] = nums[j];
                }
                // 长度-1
                len--;
                // i-1 --> 因为元素往前走了1
                i--;
            }
        }
        return len;
    }
}
```



**双指针法**

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        // 移除数组 --> 将等于val的覆盖
        int index = 0;
        for (int i=0; i < nums.length; i++) {
            if (nums[i] != val) {
                nums[index] = nums[i];
                index++;
            }
        }
        return index;
    }
}
```





## 4	有序数组的平方

### ①题目

[力扣题目链接](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

示例 1：

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

示例 2：

```
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```


提示：

1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums 已按 非递减顺序 排序


进阶：

请你设计时间复杂度为 O(n) 的算法解决本问题



### ②解题思路

-   暴力排序

    直接平方然后放回数组，然后进行排序

-   双指针法

    1.  首先它是一个有序的数组，但是有负数，负数平方之后可能会大于正数的平方
    2.  中间值不可能是最大值，要么是平方后的负数，要么就是正数
    3.  左右两个指针对应的值比较，左边大那么就左边进1，右边大就右边进1

![image-20211227201324866](E:\学习笔记\img\20211227201326.png)



### ③代码实现

-   暴力排序

    ```java
    class Solution {
        public int[] sortedSquares(int[] nums) {
            // 通过index来控制顺序
            int index = 0;
            for (int i = 0; i < nums.length; i ++) {
                // 1 平方
                nums[i] *= nums[i];
            }
            // 调用方法排序
            Arrays.sort(nums);
            return nums;
        }
    }
    ```

-   双指针法

    ```java
    class Solution {
        public int[] sortedSquares(int[] nums) {
            // 左指针
            int right = nums.length - 1;
            // 右指针
            int left = 0;
            // 新数组
            int[] newNums = new int[nums.length];
            // 索引控制新数组元素位置
            int index = nums.length - 1;
            while (left <= right) {
                // 如果左边平方大于右边的，左边进1，否则右边进1
                if (nums[left] * nums[left] > nums[right] * nums[right]) {
                    // 往后放
                    newNums[index--] = nums[left] * nums[left];
                    ++left;
                } else {
                    newNums[index--] = nums[right] * nums[right];
                    --right;
                }
            }
            return newNums;
        }
    }
    ```





## 5	长度最小的子数组

### ①题目

[力扣题目链接](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

示例：

```
输入：s = 7, nums = [2,3,1,2,4,3] 
输出：2 
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```



### ②解题思路

-   暴力破解：两个for循环

-   滑动窗口（双指针）：

    1.  left指针和right指针首先为0

    2.  通过判断sum值是否大于等于target值来判断是否移动left指针

        -   大于就left向前移动
        -   小于就right向前移动

        解释： sum值可能远远超过了target值，所以缩进左边的值来进行比较（长度最小），区间内的数可能还是可以大于target

    3.  最终就是right指针到头



### ③代码实现

**暴力破解**

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int result = Integer.MAX_VALUE;
        int minLen = 0;
        int sum = 0;
        // 暴力破解
        for (int i = 0; i < nums.length; i++) {
            // 重新赋值
            sum = 0;
            for (int j = i; j < nums.length; j++) {
                sum += nums[j];
                // 如果值等于target就进行判断
                if (sum >= target) {
                    // 加1是因为索引从0开始
                    minLen = j - i + 1;
                    result = result > minLen ? minLen : result;
                    break;
                }
            }
        }
        // 如果没有就返回0
        return result == Integer.MAX_VALUE ? 0 : result;
    }
}
```



**滑动窗口**

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int result = Integer.MAX_VALUE;
        int sum = 0;
        int left = 0;
        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];
            while ( sum >= target) {
                // +1：索引从0开始，所以长度要+1
                result = Math.min(result, right - left + 1);
                sum -= nums[left++];
            }
        }
        return result == Integer.MAX_VALUE ? 0 : result;
    }
}
```





## 6	螺旋矩阵II

[力扣题目链接](https://leetcode-cn.com/problems/spiral-matrix-ii/)

### ①题目

给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。

 

示例 1：

![img](E:\学习笔记\img\20211229193348.jpg)

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

示例 2：

```
输入：n = 1
输出：[[1]]
```


提示：

1 <= n <= 2



### ②思路

![image-20211229214901353](E:\学习笔记\img\20211229214902.png)

-   首先我们可以看到有四个指针，分别是left、right、up、down，由它们来控制开始和结束的位置
-   left 到 right： i = left，此时的数组就是`[up][i]`，然后up要++，因为下一次从5开始
-   up到down：i = up，此时的数组就是`[up][right]`，right++；下一次要从8开始
-   以此类推....

**一句话**：通过边界值来将元素放入到对应的位置，通过四个指针来控制元素位置的变化



### ③代码实现

模拟滑动

```java
class Solution {
    public int[][] generateMatrix(int n) {
        // 定义四个方向的初始值 --> 对应的索引，所以要-1
        int left = 0, right = n - 1, up = 0, down = n - 1;
        // 初始值
        int num = 1;
        // 创建一个二维数组存放数据
        int[][] res = new int[n][n];
        // 当index大于n * n时程序退出
        while (num <= n * n) {
            // 使用i的目的是不改变原有的初始值
            // 向左移动
            for (int i = left; i <= right; i++) res[up][i] = num++;
            // 下一次是列开始，所以要调整up的位置
            up++;
            // 向下移动
            for (int i = up; i <= down; i++) res[i][right] = num++;
            right--;
            for (int i = right; i >= left; i--) res[down][i] = num++;
            down--;
            for (int i = down; i >= up; i--) res[i][left] = num++;
            left++;
        }
        return res;
    }
}
```







# 二、链表

## 1	链表理论基础

### ①链表是什么

链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域，一个是指针域，数据域是用来存放数据的地方，指针域是来存放指向下一个节点指针（双链表有上一个指针），最后一个节点的指针域指向null（空指针的意思）

如图所示

![image-20211230185229145](E:\学习笔记\img\20211230185230.png)



### ②链表的类型

**单链表**

只有一个指向下一个节点的指针



**双链表**

有两个指针，一个指向上一个节点，一个指向下一个节点

双链表既可以向前查询，也可以向后查询

![image-20211230185535257](E:\学习笔记\img\20211230185536.png)



**循环链表（循环双链表）**

循环链表，顾名思义，就是链表首尾相连。

循环链表可以用来解决约瑟夫环问题。

<img src="E:\学习笔记\img\20211230185652.png" alt="image-20211230185650981" style="zoom:50%;" />



### ③链表的存储方式

数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。

链表是通过指针域的指针链接在内存中各个节点。

所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。



### ④链表的定义

这里以java为例

```java
public class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
```



### ⑤链表的操作

**删除节点**

如图所示

<img src="E:\学习笔记\img\20211230185943.png" alt="image-20211230185942674" style="zoom:80%;" />

**说明**：

-   只需要将c节点的指针域指向E节点就行了
-   在C++中要将D节点的内存释放，java和python中不用处理，有垃圾回收机制



**添加节点**

如图所示

<img src="E:\学习笔记\img\20211230190127.png" alt="image-20211230190126191" style="zoom:80%;" />

**说明**：将C的指针域指向F节点，F节点的指向域指向D节点

链表添加操作是 `$O(1)$` 操作，因为在添加元素的时候不会影响到其他元素，数组不是，数组添加的时候需要将其他元素移动，所以数组是`$O(n)$`操作



### ⑥性能分析

链表的特性和数组的特性进行比较

<img src="E:\学习笔记\img\20211230190404.png" alt="链表-链表与数据性能对比" style="zoom:50%;" />

数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。

链表的长度可以是不固定的，并且可以动态增删， **适合数据量不固定，频繁增删，较少查询的场景**。





## 2	移除链表元素

### ① 题目

[力扣题目链接](https://leetcode-cn.com/problems/remove-linked-list-elements/)

给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。

示例 1：

![img](E:\学习笔记\img\20211230190617.jpg)

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```


示例 2：

```
输入：head = [], val = 1
输出：[]
```

示例 3：

```
输入：head = [7,7,7,7], val = 7
输出：[]
```


提示：

```
列表中的节点数目在范围 [0, 104] 内
1 <= Node.val <= 50
0 <= val <= 50
```



### ② 思路

-   定义：前一个元素 pre，当前元素为前一个元素的next指向的元素 `current`
-   当 `current` 的值等于要移除的元素的值 --> 将 `pre` 的next指向 `current` 的 next
-   当 `current`的值不等于要移除的元素的值 --> 将`pre`的next指向`current`
-   最后是`pre`的next指向 `current`的next

<img src="E:\学习笔记\img\20211230195237.png" alt="image-20211230195236533" style="zoom:60%; float: left" />

虚拟头结点的方式

<img src="E:\学习笔记\img\20211230195310.png" alt="image-20211230195309608" style="zoom:60%; float: left;" />



### ③ 代码实现

**虚拟头节点**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        /*  有虚拟节点方式  */
        if (head == null) {
            return head;
        }
        // 定义一个虚拟节点
        ListNode xuni = new ListNode(-1, head);
        // 上一个节点，相对来说
        ListNode pre = xuni;
        // 当前节点
        ListNode current = xuni.next;
        // 下一个节点不为空才往下执行
        while (current != null) {
            if (current.val == val) {
                // 移除：将上一个元素的next指向当前元素的下一个元素
                pre.next = current.next;
            } else {
                // 将上一个元素修改为当前元素
                pre = current;
            }
            // 下一个元素要修改为当前元素的next
            current = current.next;
        }
        return xuni.next;
    }
}
```



**无虚拟头结点**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        /*  无虚拟头节点  */
        // 循环判断一开始的元素是否等于val
        while (head != null && head.val == val) {
            // 等于val就要移除，直接拿下一个元素做第一个元素
            head = head.next;
        }
        // 如果head为空，直接返回
        if (head == null) {
            return head;
        }
        // 上一个节点，相对来说
        ListNode pre = head;
        // 当前节点
        ListNode current = head.next;
        // 下一个节点不为空才往下执行
        while (current != null) {
            if (current.val == val) {
                // 移除：将上一个元素的next指向当前元素的下一个元素
                pre.next = current.next;
            } else {
                // 将上一个元素修改为当前元素
                pre = current;
            }
            // 下一个元素要修改为当前元素的next
            current = current.next;
        }
        return head;
    }
}
```





## 3	设计链表

### ①题目

[力扣题目链接](https://leetcode-cn.com/problems/design-linked-list/)

设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。

在链表类中实现这些功能：

get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。


示例：

```
MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3
linkedList.get(1);            //返回2
linkedList.deleteAtIndex(1);  //现在链表是1-> 3
linkedList.get(1);            //返回3
```


提示：

```
所有val值都在 [1, 1000] 之内。
操作次数将在  [1, 1000] 之内。
请不要使用内置的 LinkedList 库。
```



### ②思路

**虚拟节点的方式**：这种方式不需要考虑是否为空的情况，但是在设置first和last方法需要考虑虚拟节点

**没有虚拟节点的方式**：需要考虑到位空的情况，一开始添加元素的时候，first和last指向都是它



### ③代码实现

**单链表**

```java
// 创建一个Node类
class Node {
    int val;
    Node next;
    public Node() {}
    public Node(int val) {
        this.val = val;
    }
}

class MyLinkedList {
    // size表示存储元素的个数
    int size;
    // 虚拟头节点
    Node head;

    // 初始化虚拟头节点和size
    public MyLinkedList() {
        size = 0;
        head = new Node(0);
    }
    
    // 获取到index位置的节点的元素值
    public int get(int index) {
        // 首先判断违法情况，返回 -1
        if (index < 0 || index >= size) {
            return -1;
        }
        // 循环遍历到index
        Node currentNode = head;
        for (int i=0; i <= index; i++) {
            // 当前节点等于下一个节点
            currentNode = currentNode.next;
        }
        return currentNode.val;
    }
    
    // 将值为val的节点插入到第一个节点
    public void addAtHead(int val) {
        addAtIndex(0, val); 
    }
    
    public void addAtTail(int val) {
        addAtIndex(size, val);
    }
    
    // 如果 index 等于链表的长度，则该节点将附加到链表的末尾。
    // 如果 index 大于链表长度，则不会插入节点。
    // 如果index小于0，则在头部插入节点
    public void addAtIndex(int index, int val) {
        if (index > size) {
            return;
        }
        if (index < 0) {
            index = 0;
        }
        // 因为以上两种情况都没有，那么元素肯定是在链表中的了
        size++;
        // 插入节点的先驱
        Node pre = head;
        for (int i=0; i < index; i++) {
            pre = pre.next;
        }
        Node toAdd = new Node(val);
        toAdd.next = pre.next;
        pre.next = toAdd;
    }
    
    // 删除指定下标的元素
    // index所在元素的前一个元素指向index所在元素的下一个元素
    public void deleteAtIndex(int index) {
        // index从0开始
        if (index < 0 || index >= size) {
            return;
        }
        size--;
        Node pre = head;
        for (int i=0; i < index; i++) {
            pre = pre.next;
        }
        // 当前元素为前一个元素的下一个元素的下一个元素
        pre.next = pre.next.next;
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```



**双链表**

```java
class MyLinkedList {
    // 元素个数
    int size;
    // 保存头结点和尾节点
    ListNode first, last;

    class ListNode {
        int val;
        ListNode prev, next;
        public ListNode(int val) {
            this.val = val;
        }
    }

    public MyLinkedList() {
        size = 0;
        first = new ListNode(0);
        last = new ListNode(0);
        first.next = last;
        last.prev = first;
    }
    
    public int get(int index) {
        // 首先判断索引是否有效
        if (index >= size || index < 0) { return -1; }
        // 首先当前元素为头节点元素
        ListNode cur = first;
        // 通过判断index的位置来决定是从头节点遍历，还是从尾节点遍历，提高效率
        if (index < (size - 1) / 2) {
            for (int i=0; i <= index; i++) {
                cur = cur.next;
            }
        } else {
            cur = last;
            for (int i=0; i <= size - 1 - index; i++) {
                cur = cur.prev;
            }
        }
        return cur.val;
    }
    
    /* 将新节点的next指向当前的head，然后将设置为新节点 */
    public void addAtHead(int val) {
        ListNode cur = first;
        ListNode newNode = new ListNode(val);
        // cur是虚拟节点
        newNode.next = cur.next;
        newNode.prev = cur;
        cur.next.prev = newNode;
        cur.next = newNode;
        size++;
    }
    
    /* 将当前的last的next指向新节点，将新节点的prev指向当前的last */
    public void addAtTail(int val) {
        ListNode cur = last;
        ListNode newNode = new ListNode(val);
        // cur是虚拟节点
        newNode.next = last;
        newNode.prev = cur.prev;
        cur.prev.next = newNode;
        cur.prev = newNode;
        size++;
    }
    
    public void addAtIndex(int index, int val) {
        // 判断索引有效性
        if (index > size) { return; }
        if (index < 0) { index = 0; }

        ListNode cur = first;
        for (int i=0; i < index; i++) {
            cur = cur.next;
        }
        ListNode newNode = new ListNode(val);
        // 当前元素的next指向当前元素的下一个元素
        newNode.next = cur.next;
        // 将当前元素的next指向的元素的prev指向新元素
        cur.next.prev = newNode;
        // 当期元素prev指向当前元素
        newNode.prev = cur;
        // 将当前元素的next指向新元素
        cur.next = newNode;
        // 元素加1
        size++;
    }
    
    public void deleteAtIndex(int index) {
        // 判断索引有效性
        if (index >= size || index < 0) return;
        // pred是删除元素的上一个元素，succ是删除元素的下一个元素
        ListNode prev, succ;
        // 提高效率
        if (index < (size - 1) / 2) {
            prev = first;
            for (int i=0; i < index; i++) {
                prev = prev.next;
            }
            succ = prev.next.next;
        } else {
            succ = last;
            for (int i=0; i < size - 1 - index; i++) {
                succ = succ.prev;
            }
            prev = succ.prev.prev;
        }
        prev.next = succ;
        succ.prev = prev;
        size--;
    }
}
```







## 4	反转链表

### ①题目

[力扣题目链接](https://leetcode-cn.com/problems/reverse-linked-list/)

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例**: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL



### ②思路

-   **双指针法**：一个指针指向前一个(prev)，一个指针指向当前元素(cur)，通过将 `next -> prev`来达到反转
-   **递归双指针法**：这也是双指针，通过变换prev和cur来实现反转

![image-20220103212255724](E:\学习笔记\img\20220103212256.png)



### ③代码实现

**双指针法**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        // 上一个节点
        ListNode prev = null;
        // 当前节点
        ListNode cur = head;
        // 保存当前节点
        ListNode temp = null;
        while (cur != null) {
            // 保存下一个节点，因为prev会变成当前节点
            temp = cur.next;
            cur.next = prev;
            // 此时的上一个节点就是当前节点
            prev = cur;
            // 此时的下一个节点就是当前节点的下一个节点
            cur = temp;
        }
        return prev;
    }
}
```



**递归双指针法**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        return reserve(null, head);
    }

    /* 递归双指针 */
    public ListNode reserve(ListNode prev, ListNode cur) {
        if (cur == null) return prev;
        ListNode temp = null;
        // 保存下一个节点
        temp = cur.next;
        cur.next = prev;
        // 第一个参数是前一个节点，第二个参数是当前节点
        return reserve(cur, temp);
    }
}
```





## 5	两两交换链表中的节点

### ①题目

[力扣题目链接(opens new window)](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

示例1：

![img](E:\学习笔记\img\20220103212535.jpg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

示例 2：

```
输入：head = []
输出：[]
```

示例 3：

```
输入：head = [1]
输出：[1]
```



### ②思路





### ③代码实现







