# 一、概述

![image-20230421103234763](E:\学习笔记\img\img01\image-20230421103234763.png)

信息化世界的组成由数据机构、操作系统、计算机组成原理好计算机网络四大部件组成，接下来我们学习计算机组成原理来帮助我们认识计算机底层是如何进行工作的。





## 1.1 认识现代计算机硬件

![image-20230421103436296](E:\学习笔记\img\img01\image-20230421103436296.png)

在图中我们有CPU、内存条和主板，除此之外还有很多的外部设备，比如鼠标、键盘和硬盘等等，由它们来组成我们的计算机。不止是PC机，我们还有手机、电子手表、MP3等多种类型的小型计算机。



## 1.2 计算机系统



### 1.2.1 硬件的发展

![image-20230421103836331](E:\学习笔记\img\img01\image-20230421103836331-16820677227551.png)

![image-20230421104409841](E:\学习笔记\img\img01\image-20230421104409841.png)

**摩尔定律**

![image-20230421104448018](E:\学习笔记\img\img01\image-20230421104448018.png)





### 1.2.2 软件的发展

![image-20230421103715190](E:\学习笔记\img\img01\image-20230421103715190.png)

-   应用软件：比如微信、抖音、淘宝。。。
-   系统软件：数据管理系统、图书管理系统等等



**目前的发展趋势**

![image-20230421104743789](E:\学习笔记\img\img01\image-20230421104743789.png)





## 1.3 计算机硬件基本组成

### 1.3.1 早期冯诺依曼机

![image-20230421111130633](E:\学习笔记\img\img01\image-20230421111130633.png)



### 1.3.2 现代计算机的结构

由于冯诺依曼机过于依赖运算器，所以在现代计算机中解放了运算器，让它不再是中心，而是存储器为中心，运算器只负责运算任务，这样的好处就是将运算器解耦出来

![image-20230421111504151](E:\学习笔记\img\img01\image-20230421111504151.png)

![image-20230421111652238](E:\学习笔记\img\img01\image-20230421111652238.png)

⚠：在计组中的主机不等于是实际的主机



## 1.4 各硬件的工作原理

### 1.4.1 主存储器的基本组成

![image-20230421112257365](E:\学习笔记\img\img01\image-20230421112257365.png)

-   MAR：负责接收控制信号然后执行操作
-   MDR：负责将结果返回出去

用实际的案例来说明：主存储体相当于是一个快递驿站，MAR是店员，主要负责接收来自客户的信息，然后处理信息，接着由MDR将用户需要的快递交给用户，在此过程中，店员需要知道用户的快递单号来到货架中寻找对应位置的快递，这个快递单号就相当于是计算机中的地址值，通过这个获取内存中的控制信息和存储的数据，找到对应位置的快递就需要将快递交给客户，交接的位置就是在柜台。



### 1.4.2 运算器

![image-20230421113224804](E:\学习笔记\img\img01\image-20230421113224804.png)

执行顺序：

-   数据首先会进入到 X（通用寄存器中）
-   接着由控制器来发出信号告诉运算器是加法运算还是乘法运算
-   如果是加法运算，就会将数据放入到ACC中
-   如果是乘法运算，会将数据放入到MQ中
-   最后不管是加法还是乘法，结果都是放到ACC中



### 1.4.3 控制器

![image-20230421113156332](E:\学习笔记\img\img01\image-20230421113156332.png)

顾名思义，控制器就是负责控制程序的运行，它就相当于是一个总指挥，指挥着各个部件有条不紊的运行。

首先它会从主存储器中获取指令，接着将获取到的指令信息进行分析，会得到 `操作码`和`地址码`，`操作码`是告诉计算机此时要进行什么操作的代码，`地址码`是操作的数据存储的位置。接着就是控制对应部件来执行操作。





## 1.5 计算机的工作过程

### 1.5.1 第一步：编译

翻译成机器码放入到主存中

![image-20230425101615483](E:\学习笔记\img\img01\image-20230425101615483.png)



### 1.6.2 第二步：执行

**取数操作**

![image-20230425101856572](E:\学习笔记\img\img01\image-20230425101856572.png)

1.  通过PC获取当前执行指令的位置，为0，对应图中的 0号位置
2.  通过MAR获取 0号位置 的指令
3.  返回给MDR
4.  获取到的指令交给 IR 进行存储
5.  IR 将 `操作码` 交给 CU进行分析
6.  IR将 `地址码 0101=5` 放到 MAR中
7.  MAR去存储体中获取地址为 5 的数据
8.  获取到的数据放入到MDR中
9.  CU 发出指令将 MDR中的数据放入到 ACC中

接下来的乘法操作也是类似的，有一点不同的就是，乘法的被乘数是放到MQ当中的，而加法是放入到 X 当中，得出的结果是都是放入到ACC中，最后是ACC通过数据总线将数据放入到 MDR中，CU控制单元向主存储器发出写的信号，最终是将MDR中的数据写入到了存储体当中。自此就完成了一个简单的算数运算。



## 1.6 性能指标

### 1.6.1 存储器

![image-20230424115837732](E:\学习笔记\img\img01\image-20230424115837732.png)



### 1.6.2 CPU

![image-20230424121659149](E:\学习笔记\img\img01\image-20230424121659149.png)

**说明**：

-   CPU主频：CPU内数字脉冲信号震荡的频率，1秒内所能执行多少的时钟周期，这是为了确保内部所有硬件单元能够协同工作和同步。

    例子：广播体操中老师在上面喊 1 2 3 4，我们就跟着这个口号执行对应的动作，这样我们就可以整齐的同步执行。唱歌也是如此，通过音乐节奏来整齐进入齐唱。

-   CPU时钟周期：它是主频中的最小单位，一个时钟周期相当于是广播体操中的1，不同的时钟周期内执行不同的操作，当然也有操作是需要执行多个时钟周期。可以把它理解为是音乐中的打拍子

-   CPI：执行一条指令的所需的时钟周期数，但是指令的耗时有很多影响因素，**所以一般都是说平均CPI**

-   CPU执行时间计算：计算出所需要的时钟周期数和时钟周期，两者相乘就得到了执行时间
    $$
    CPU时钟周期数 = 平均CPI * 指令条数
    $$

    $$
    CPU时钟周期 = 1 / CPU主频
    $$

    $$
    CPU执行时间 = CPU时钟周期数 * CPU时钟周期 = 平均CPU * 指令条数 / CPU主频
    $$

![image-20230424121918085](E:\学习笔记\img\img01\image-20230424121918085.png)



### 1.6.3 系统整体

![image-20230424121959135](E:\学习笔记\img\img01\image-20230424121959135.png)

![image-20230424122023153](E:\学习笔记\img\img01\image-20230424122023153.png)

![image-20230424122039766](E:\学习笔记\img\img01\image-20230424122039766.png)







# 二、数据的表示

## 2.1 进制表示

### 2.1.1 常见进制

进制：表示一个数到达对应的数值就要进位，比如我们人们常用的进制就是十进制，因为我们有十根手指，所以在到十的时候就需要进位，因为十一我们没有手指算了，需要用一个东西来表示十，比如用一横来表示十。

-   十进制

    逢十进一

-   二进制

    逢二进一

-   八进制

    逢八进一

-   十六进制

    逢十六进一

二进制常见表示

![image-20230425105831407](E:\学习笔记\img\img01\image-20230425105831407.png)



### 2.1.2 进制转换

#### 其他进制转换成十进制

##### ①二进制转十进制

**规则**:从最低位开始，将每个位上的数提取出来，乘以2的(位数-1)次方，然后求和。

**案例**:将二进制1011转成十进制的数

1011 = 1 * 2^0 + 1 * 2^1 + 0 * 1^2 + 1 * 2^3 = 1 + 2 + 0 + 8 = 11



##### ②八进制转十进制

**规则**:从最低位开始，将每个位上的数提取出来，乘以8的(位数-1)次方，然后求和。

**案例**:将0123转成十进制的数

0123 = 3 * 8^0 + 2 * 8^1 + 1 * 8^2 = 3 + 16 + 64 = 83



##### ③十六进制转十进制

**规则**:从最低位开始，将每个位上的数提取出来，乘以16的(位数-1)次方，然后求和

**案例**:将0X34A转成十进制的数

0X34A = 10 * 16^0 + 4 * 16^1 + 3 * 16^2 = 10 + 64 + 768 = 842



**课后练习**

**110001100转成干进制**

2^2 + 2^3 + 2^7 + 2^8 = 4 + 8 + 128 + 256 = 396



**02456转成十进制**

6 * 8^0 + 5 * 8^1 + 4 * 8^2 + 2 * 8^3 = 6 + 40 + 256 + 1024 = 1326



**0xA45转成十进制**

5 * 16^0 + 4 * 16^1 + 10 * 16^2 = 5 + 64 + 2560 = 2629



#### 十进制转其他进制

##### ①十进制转二进制

**规则**:将该数不断除以2，直到商为0为止，然后将每步得到的余数倒过来，就是对应的二进制。

**案例**:将56转成二进制

![image-20210822172658171](E:\学习笔记\img\20210822172659.png)



##### ②十进制转八进制

 **规则**:将该数不断除以8，直到商为0为止，然后将每步得到的余数倒过来，就是对应的八进制。

**案例**:请将156转成八进制

234



##### ③十进制转十六进制

 **规则**:将该数不断除以16,直到南为0为止，然后将每步得到的余数倒过来，就是对应的十六进制。

**案例**:请将356转成十六进制

164



**课堂练习**

![image-20210822172901400](E:\学习笔记\img\20210822172903.png)

123 -> 0111 1011

678 -> 01246

8912 -> 0X22D0



#### 二进制转八进制和十六进制

##### ①二转八

**规则**:从低位开始，将=二进制数**每三位一组**， 转成对应的八进制数即可。

**案例**:请将11010101转成八进制

11 010 101 -> 0325



##### ②二转十六

**规则**:低位开始，将二进制数**每四位一组**, 转成对应的十六进制数即可。

**案例**:请将11010101转成十六进制

1101 0101 -> 0XD5



**练习**

![image-20210822174855460](E:\学习笔记\img\20210822174857.png)

11 100 101 -> 0345

11 1001 0110 -> 0X396



#### 八进制和十六进制转二进制

##### ①八转二

**规则**:将八进制数每1位，转成对应的一一个3位的二进制数即可。

**案例**:请将0237转成二进制

0237 -> 01 011 111



##### ②十六转二

**规则**:将十六进制数每1位，转成对应的4位的-一个二进制数即可。

**案例**:请将0x23B转成二进制

0x23B -> 0010 0011 1011



**练习**

![image-20210824213455239](E:\学习笔记\img\20210824213457.png)

01230 -> 1 010 011 000

0XAB29 -> 1010 1011 0010 1001 



### 2.1.3 BCD码

用二进制编码的十进制，方便计算



#### 8421码

4个位表示，对应不同的权值，需要有权值表示

![image-20230509113638029](E:\学习笔记\img\img01\image-20230509113638029.png)

值超出 9 就需要 + 6(0110) 进行修正，因为刚好是超出15(1111) 进位

例子：8 + 8

```sh
	1000
+	1000
=  10000
# 超出了9需要修正
   10000
+   0110
=  10110
# 结果 = 00010110
# 转换十进制 = 16
```

 

#### 余3码

![image-20230509113625063](E:\学习笔记\img\img01\image-20230509113625063.png)



#### 2421码

4个位的权值发生变化

![image-20230509113657101](E:\学习笔记\img\img01\image-20230509113657101.png)





## 2.2 整数运算

在计算机中，底层计算采用的是二进制的方式进行计算，所能操作的最大位数是由机器字长决定，现在的计算机的字长大部分为32或64，也就是说数值的存储最大可以是 32 位或 64的值

在本章节中使用 8 字长的举例子



### 2.2.1 无符号整数

**无符号整数的表示**

无符号整数可以理解为全是正数，也就是没有符号位，那么 8 字长的可以表示如下

![image-20230509154351259](E:\学习笔记\img\img01\image-20230509154351259.png)

无符号整数能够表示的数据范围为 `0 ~ 2^n - 1`



**无符号整数的运算**

-   加法

    从最低位相加，按位相加，并往更高位进位

    ```sh
    12	+	6	=	18
    	
    	1100
    +	0110
    =   10010	=	18
    ```

-   减法

    ![image-20230509155423009](E:\学习笔记\img\img01\image-20230509155423009.png)



### 2.2.2 有符号整数

有符号整数的最高位为符号位，0表示正数，1表示负数

由于符号位的存在导致计算的时候不能使用无符号整数的方式去计算，因为最高位不知道取什么值，它可能是正数和负数相加的情况。为了更方便的计算，科学家们想出了使用补码的方式进行计算，将数转换成补码然后再进行计算，不需要考虑正数和负数的情况。

下面讲解原码、反码和补码

**正数**：

-   原码、反码和补码全部一样

**负数**：

-   原码：数据本身的二进制

    如 -4 的原码为 1000 0100

-   反码：除了符号位，其他位取反 

    如 4 的反码为 1111 1011

-   补码：反码 + 1

    如 4 的补码为 1111 1100

![image-20230509103155197](E:\学习笔记\img\img01\image-20230509103155197.png)

**小技巧（解题）**：

![image-20230509160257288](E:\学习笔记\img\img01\image-20230509160257288.png)

![image-20230509160402586](E:\学习笔记\img\img01\image-20230509160402586.png)

这个是用在减法的时候转换使用的，因为计算机大多数使用加法器，所以会将减法转换加法去进行运算



**加法运算**

![image-20230509104337901](E:\学习笔记\img\img01\image-20230509104337901.png)



## 2.3 浮点数运算















# 三、运算器





# 课堂实验

## 一、TEC-8使用

### 1.1、介绍





### 1.2 运行原理



![image-20230303181004238](E:\学习笔记\img\img01\image-20230303181004238.png)

**运行步骤**

1.  数据通过数据开关进来，通过`2-4译码器`选择对应的存储器进行存储，图中有4个存储器，分别是`R0-R4`，比如数据译码器的结果是`LR0`，则放到R0位置
2.  接着数据初始化到`PC（程序计数器）`
3.  `PC`存放接下来要执行的指令逻辑，通过`双端口RAM`获取对应的执行指令
4.  将获取到的指令交给`IR（指令寄存器）`进行译码，译码有两部分
    -   控制指令：这里的机器有两个控制器，分别是微程序控制器和硬连线控制器，它负责控制执行的顺序和逻辑
    -   存储指令：`2选1选择器`表示2位去1个值，它的值有`00`、`01`、`10`、`11`，从这4个中选出一个，在存储的时候已经按照对应的逻辑进行了存储，所以在选择的时候也是按照相应的逻辑获取
5.  控制指令控制`选择器A`和`选择器B`获取对应的值
6.  将获取到的值进行运算

==注意：总线的数据不是一次性的，它可以放到任何位置。==

